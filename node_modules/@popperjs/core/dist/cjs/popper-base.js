/**
 * @popperjs/core v2.0.0-alpha.1
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var placements = basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

var getBoundingClientRect = (function (element) {
  var rect = JSON.parse(JSON.stringify(element.getBoundingClientRect()));
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
});

function getWindow(node) {
  var ownerDocument = node != null && typeof node === 'object' && node.hasOwnProperty('ownerDocument') ? // $FlowFixMe: assume ownerDocument to be the one we are looking for
  node.ownerDocument : null;
  return ownerDocument != null ? ownerDocument.defaultView : window;
}

function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

/*:: declare function isElement(node: mixed): boolean %checks(node instanceof
  Element); */

function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement;
}
/*:: declare function isHTMLElement(node: mixed): boolean %checks(node instanceof
  HTMLElement); */


function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement;
}
/*:: declare function isShadowRoot(node: mixed): boolean %checks(node instanceof
  ShadowRoot); */


function isShadowRoot(node) {
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement;
}

function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

var getScrollSum = (function (scrollParents) {
  return scrollParents.reduce(function (scroll, scrollParent) {
    var nodeScroll = getNodeScroll(scrollParent);
    scroll.scrollTop += nodeScroll.scrollTop;
    scroll.scrollLeft += nodeScroll.scrollLeft;
    return scroll;
  }, {
    scrollTop: 0,
    scrollLeft: 0
  });
});

var unwrapVirtualElement = (function (element) {
  return isElement(element) ? element : element.contextElement;
});

// Composite means it takes into account transforms as well as layout.

var getCompositeRect = (function (elementOrVirtualElement, commonOffsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var element = unwrapVirtualElement(elementOrVirtualElement);
  var rect = getBoundingClientRect(element);
  var offsetParentRect = isElement(commonOffsetParent) && !isFixed ? getBoundingClientRect(commonOffsetParent) : {
    left: 0,
    top: 0
  };
  var offsetParentScrollSum = getScrollSum(isFixed ? [] : [commonOffsetParent]);
  var width = rect.width;
  var height = rect.height;
  var x = rect.left + offsetParentScrollSum.scrollLeft - offsetParentRect.left;
  var y = rect.top + offsetParentScrollSum.scrollTop - offsetParentRect.top;
  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
});

// Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.
var getLayoutRect = (function (element) {
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: element.offsetWidth,
    height: element.offsetHeight
  };
});

var getNodeName = (function (element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
});

var getParentNode = (function (element) {
  if (getNodeName(element) === 'html') {
    // DocumentElement detectedF
    return element;
  }

  return element.parentNode || // DOM Element detected
  // $FlowFixMe: need a better way to handle this...
  element.host || // ShadowRoot detected
  document.ownerDocument || // Fallback to ownerDocument if available
  document.documentElement // Or to documentElement if everything else fails
  ;
});

function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

function getScrollParent(node) {
  if (['html', 'body', '#document'].includes(getNodeName(node))) {
    return node.ownerDocument.body;
  }

  if (isHTMLElement(node)) {
    // Firefox want us to check `-x` and `-y` variations as well
    var _getComputedStyle = getComputedStyle(node),
        overflow = _getComputedStyle.overflow,
        overflowX = _getComputedStyle.overflowX,
        overflowY = _getComputedStyle.overflowY;

    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return node;
    }
  }

  return getScrollParent(getParentNode(node));
}

function listScrollParents(element, list) {
  if (list === void 0) {
    list = [];
  }

  var scrollParent = getScrollParent(element);
  var isBody = getNodeName(scrollParent) === 'body';
  var target = isBody ? getWindow(scrollParent) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}

var getElementMargins = (function (element) {
  // get the element margins, we need them to properly align the popper
  var styles = getComputedStyle(element);
  var top = parseFloat(styles.marginTop) || 0;
  var right = parseFloat(styles.marginRight) || 0;
  var bottom = parseFloat(styles.marginBottom) || 0;
  var left = parseFloat(styles.marginLeft) || 0;
  return {
    top: top,
    right: right,
    bottom: bottom,
    left: left
  };
});

var addClientRectMargins = (function (rect, element) {
  var margins = getElementMargins(element);
  return {
    width: rect.width + margins.left + margins.right,
    height: rect.height + margins.top + margins.bottom,
    y: rect.y - margins.top,
    x: rect.x - margins.left
  };
});

var isTableElement = (function (element) {
  return ['table', 'td', 'th'].includes(getNodeName(element));
});

var getTrueOffsetParent = function getTrueOffsetParent(element) {
  return isHTMLElement(element) ? element.offsetParent : null;
};

function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element); // Find the nearest non-table offsetParent

  while (offsetParent && isTableElement(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static') {
    return window;
  }

  return offsetParent || window;
}

function isOffsetContainer(element) {
  var firstElementChild = element.firstElementChild;
  return !firstElementChild || getOffsetParent(firstElementChild) === element;
}

function getRoot(node) {
  var parentNode = node.parentNode;

  if (parentNode != null) {
    return getRoot(parentNode);
  }

  return node;
}

function getCommonOffsetParent(element1, element2) {
  // If one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  var element2root = getRoot(element2);

  if (isShadowRoot(element1root)) {
    return getCommonOffsetParent(element1root.host, element2);
  } else if (isShadowRoot(element2root)) {
    return getCommonOffsetParent(element1, element2root.host);
  } // Here we make sure to give as "start" the element that comes first in the DOM


  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1; // Both nodes are inside #document
  // Get common ancestor container

  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer; // If ancestor container is not an element, we must return a safe
  // fallback, body is a good bet

  if (!isElement(commonAncestorContainer)) {
    return getWindow(commonAncestorContainer).body;
  } // if ancestor container is also an offset container, we found our winner


  if (isOffsetContainer(commonAncestorContainer)) {
    return commonAncestorContainer;
  }

  return getOffsetParent(commonAncestorContainer);
}

var unwrapJqueryElement = (function (element) {
  return (// $FlowFixMe: need to get type refinement work
    element.hasOwnProperty('jquery') ? element[0] : element
  );
});

var order = function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.optionallyRequires || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
};

var orderModifiers = (function (modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
});

function microtaskDebounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

var format = (function (str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return [].concat(args).reduce(function (p, c) {
    return p.replace(/%s/, c);
  }, str);
});

var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'onLoad', 'requires', 'options'];
var validateModifiers = (function (modifiers) {
  modifiers.forEach(function (modifier) {
    Object.keys(modifier).forEach(function (key) {
      switch (key) {
        case 'name':
          if (typeof modifier.name !== 'string') {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
          }

          break;

        case 'enabled':
          if (typeof modifier.enabled !== 'boolean') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
          }

        case 'phase':
          if (!modifierPhases.includes(modifier.phase)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
          }

          break;

        case 'fn':
          if (typeof modifier.fn !== 'function') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'onLoad':
          if (typeof modifier.onLoad !== 'function') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"onLoad"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'onDestroy':
          if (typeof modifier.onDestroy !== 'function') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"onDestroy"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'requires':
          if (!Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
          }

          break;

        case 'optionallyRequires':
          if (!Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
          }

          break;

        case 'options':
        case 'data':
          break;

        default:
          console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
            return "\"" + s + "\"";
          }).join(', ') + "; but \"" + key + "\" was provided.");
      }

      modifier.requires && modifier.requires.forEach(function (requirement) {
        if (modifiers.find(function (mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
});

var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided to Popper, they must be either a valid DOM element, virtual element, or a jQuery-wrapped DOM element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';

var areValidElements = function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
};

var defaultOptionsValue = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? defaultOptionsValue : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    // Unwrap `reference` and `popper` elements in case they are
    // wrapped by jQuery, otherwise consume them as is
    var referenceElement = unwrapJqueryElement(reference);
    var popperElement = unwrapJqueryElement(popper);
    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, defaultOptionsValue, {}, defaultOptions),
      modifiersData: {},
      elements: {
        reference: referenceElement,
        popper: popperElement
      },
      attributes: {},
      styles: {}
    };
    var instance = {
      setOptions: function setOptions(options) {
        // Store options into state
        state.options = Object.assign({}, defaultOptions, {}, options);
        state.scrollParents = {
          reference: listScrollParents(referenceElement),
          popper: listScrollParents(popperElement)
        }; // Order `options.modifiers` so that the dependencies are fulfilled
        // once the modifiers are executed

        state.orderedModifiers = orderModifiers([].concat(state.options.modifiers.filter(function (modifier) {
          return !defaultModifiers.find(function (_ref) {
            var name = _ref.name;
            return name === modifier.name;
          });
        }), defaultModifiers.map(function (defaultModifier) {
          return Object.assign({}, defaultModifier, {}, state.options.modifiers.find(function (_ref2) {
            var name = _ref2.name;
            return name === defaultModifier.name;
          }));
        }))); // Validate the provided modifiers so that the consumer will get warned
        // if one of the custom modifiers is invalid for any reason

        {
          validateModifiers(state.orderedModifiers);
        }
      },
      // Syncronous and forcefully executed update
      // it will always be executed even if not necessary, usually NOT needed
      // use Popper#update instead
      forceUpdate: function forceUpdate() {
        var _state$elements = state.elements,
            referenceElement = _state$elements.reference,
            popperElement = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements anymore

        if (!areValidElements(referenceElement, popperElement)) {
          {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return;
        }

        var isFixed = state.options.strategy === 'fixed'; // Get initial measurements
        // these are going to be used to compute the initial popper offsets
        // and as cache for any modifier that needs them later

        state.measures = {
          reference: getCompositeRect(referenceElement, getCommonOffsetParent(unwrapVirtualElement(referenceElement), popperElement), isFixed),
          // CSS marginsc an be applied to popper elements to quickly
          // apply offsets dynamically based on some CSS selectors.
          // For this reason we include margins in this calculation.
          popper: addClientRectMargins(getLayoutRect(popperElement), popperElement)
        }; // Modifiers have the ability to read the current Popper state, included
        // the popper offsets, and modify it to address specifc cases

        state.reset = false; // Cache the placement in cache to make it available to the modifiers
        // modifiers will modify this one (rather than the one in options)

        var prevPlacement = state.placement;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          {
            __debug_loops__ += 1;

            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }

          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              enabled = _state$orderedModifie.enabled,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (enabled && typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            });
          }
        } // Prevents a jitter if elements' size changes based on placement.
        // This is separate from and does not solve the "flip flicker" issue.
        // We can't know ahead of time (before the placement gets written to the
        // DOM) what size the element will be due to conditionally applied/
        // computed CSS based on placement (e.g. margins on arrow)


        if (prevPlacement !== state.placement) {
          instance.forceUpdate();
        }
      },
      // Async and optimistically optimized update
      // it will not be executed if not necessary
      // debounced, so that it only runs at most once-per-tick
      update: microtaskDebounce(function () {
        return (// prettier-ignore
          new Promise(function (resolve) {
            instance.forceUpdate();
            resolve(state);
          })
        );
      }),
      destroy: function destroy() {
        // Run `onDestroy` modifier methods
        state.orderedModifiers.forEach(function (_ref3) {
          var onDestroy = _ref3.onDestroy,
              enabled = _ref3.enabled,
              name = _ref3.name,
              _ref3$options = _ref3.options,
              options = _ref3$options === void 0 ? {} : _ref3$options;
          return enabled && onDestroy && onDestroy({
            state: state,
            name: name,
            instance: instance,
            options: options
          });
        });
      }
    }; // Don't proceed if `reference` or `popper` are invalid elements

    if (!areValidElements(referenceElement, popperElement)) {
      {
        console.error(INVALID_ELEMENT_ERROR);
      }

      return instance;
    }

    instance.setOptions(options); // Modifiers have the opportunity to execute some arbitrary code before
    // the first update cycle is ran, the order of execution will be the same
    // defined by the modifier dependencies directive.
    // The `onLoad` function may add or alter the options of themselves

    state.orderedModifiers.forEach(function (_ref4) {
      var onLoad = _ref4.onLoad,
          enabled = _ref4.enabled,
          name = _ref4.name,
          _ref4$options = _ref4.options,
          options = _ref4$options === void 0 ? {} : _ref4$options;
      return enabled && onLoad && (state = onLoad({
        state: state,
        name: name,
        instance: instance,
        options: options
      }) || state);
    });
    instance.update();
    return instance;
  };
}
var createPopper = popperGenerator();

exports.createPopper = createPopper;
exports.popperGenerator = popperGenerator;
//# sourceMappingURL=popper-base.js.map
