{"version":3,"file":"popper-lite.min.js","sources":["../../src/dom-utils/getWindow.js","../../src/dom-utils/instanceOf.js","../../src/dom-utils/getComputedStyle.js","../../src/dom-utils/listScrollParents.js","../../src/dom-utils/getScrollParent.js","../../src/dom-utils/getOffsetParent.js","../../src/dom-utils/isTableElement.js","../../src/dom-utils/getCommonOffsetParent.js","../../src/utils/debounce.js","../../src/index.js","../../src/dom-utils/getLayoutRect.js","../../src/modifiers/eventListeners.js","../../src/enums.js","../../src/dom-utils/getBoundingClientRect.js","../../src/dom-utils/unwrapVirtualElement.js","../../src/dom-utils/getCompositeRect.js","../../src/dom-utils/getScrollSum.js","../../src/dom-utils/getNodeScroll.js","../../src/dom-utils/getHTMLElementScroll.js","../../src/dom-utils/getWindowScroll.js","../../src/dom-utils/getNodeName.js","../../src/dom-utils/getParentNode.js","../../src/dom-utils/addClientRectMargins.js","../../src/dom-utils/getElementMargins.js","../../src/utils/unwrapJqueryElement.js","../../src/utils/orderModifiers.js","../../src/modifiers/computeStyles.js","../../src/popper-lite.js","../../src/modifiers/popperOffsets.js","../../src/utils/computeOffsets.js","../../src/utils/getBasePlacement.js","../../src/utils/getVariationPlacement.js","../../src/utils/getMainAxisFromPlacement.js","../../src/modifiers/applyStyles.js"],"sourcesContent":["// @flow\nexport default function getWindow(node: mixed) {\n  const ownerDocument: ?Document =\n    node != null &&\n    typeof node === 'object' &&\n    node.hasOwnProperty('ownerDocument')\n      ? // $FlowFixMe: assume ownerDocument to be the one we are looking for\n        node.ownerDocument\n      : null;\n  return ownerDocument != null ? ownerDocument.defaultView : window;\n}\n","// @flow\nimport getWindow from './getWindow';\n\n/*:: declare function isElement(node: mixed): boolean %checks(node instanceof\n  Element); */\n\nfunction isElement(node) {\n  const OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement;\n}\n\n/*:: declare function isHTMLElement(node: mixed): boolean %checks(node instanceof\n  HTMLElement); */\n\nfunction isHTMLElement(node) {\n  const OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement;\n}\n\n/*:: declare function isShadowRoot(node: mixed): boolean %checks(node instanceof\n  ShadowRoot); */\n\nfunction isShadowRoot(node) {\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement;\n}\n\nexport { isElement, isHTMLElement, isShadowRoot };\n","// @flow\nimport getWindow from './getWindow';\n\nexport default function getComputedStyle(\n  element: Element\n): CSSStyleDeclaration {\n  return getWindow(element).getComputedStyle(element);\n}\n","// @flow\nimport getScrollParent from './getScrollParent';\nimport getParentNode from './getParentNode';\nimport getNodeName from './getNodeName';\nimport getWindow from './getWindow';\n\nexport default function listScrollParents(\n  element: Node,\n  list: Array<Element> = []\n): Array<Element> {\n  const scrollParent = getScrollParent(element);\n  const isBody = getNodeName(scrollParent) === 'body';\n  const target = isBody ? getWindow(scrollParent) : scrollParent;\n  const updatedList = list.concat(target);\n  return isBody\n    ? updatedList\n    : updatedList.concat(listScrollParents(getParentNode(target)));\n}\n","// @flow\nimport getParentNode from './getParentNode';\nimport getComputedStyle from './getComputedStyle';\nimport getNodeName from './getNodeName';\nimport { isHTMLElement } from './instanceOf';\n\nexport default function getScrollParent(node: Node): HTMLElement {\n  if (['html', 'body', '#document'].includes(getNodeName(node))) {\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node)) {\n    // Firefox want us to check `-x` and `-y` variations as well\n    const { overflow, overflowX, overflowY } = getComputedStyle(node);\n    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n      return node;\n    }\n  }\n\n  return getScrollParent(getParentNode(node));\n}\n","// @flow\nimport getWindow from './getWindow';\nimport getNodeName from './getNodeName';\nimport getComputedStyle from './getComputedStyle';\nimport { isHTMLElement } from './instanceOf';\nimport isTableElement from './isTableElement';\n\nconst getTrueOffsetParent = (element: Element): ?Element =>\n  isHTMLElement(element) ? element.offsetParent : null;\n\nexport default function getOffsetParent(element: Element) {\n  const window = getWindow(element);\n\n  let offsetParent = getTrueOffsetParent(element);\n\n  // Find the nearest non-table offsetParent\n  while (offsetParent && isTableElement(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (\n    offsetParent &&\n    getNodeName(offsetParent) === 'body' &&\n    getComputedStyle(offsetParent).position === 'static'\n  ) {\n    return window;\n  }\n\n  return offsetParent || window;\n}\n","// @flow\nimport getNodeName from './getNodeName';\n\nexport default (element: Element): boolean =>\n  ['table', 'td', 'th'].includes(getNodeName(element));\n","// @flow\nimport getOffsetParent from './getOffsetParent';\nimport { isElement, isShadowRoot } from './instanceOf';\nimport getWindow from './getWindow';\n\nfunction isOffsetContainer(element: Element): boolean {\n  const firstElementChild = element.firstElementChild;\n  return !firstElementChild || getOffsetParent(firstElementChild) === element;\n}\n\nfunction getRoot(node: Node): Node {\n  const parentNode = node.parentNode;\n\n  if (parentNode != null) {\n    return getRoot(parentNode);\n  }\n\n  return node;\n}\n\nexport default function getCommonOffsetParent(\n  element1: Element,\n  element2: Element\n): Element {\n  // If one of the nodes is inside shadowDOM, find which one\n  const element1root = getRoot(element1);\n  const element2root = getRoot(element2);\n\n  if (isShadowRoot(element1root)) {\n    return getCommonOffsetParent(element1root.host, element2);\n  } else if (isShadowRoot(element2root)) {\n    return getCommonOffsetParent(element1, element2root.host);\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  const order =\n    element1.compareDocumentPosition(element2) &\n    Node.DOCUMENT_POSITION_FOLLOWING;\n  const start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n\n  // Both nodes are inside #document\n  // Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  const commonAncestorContainer = range.commonAncestorContainer;\n\n  // If ancestor container is not an element, we must return a safe\n  // fallback, body is a good bet\n  if (!isElement(commonAncestorContainer)) {\n    return getWindow(commonAncestorContainer).body;\n  }\n\n  // if ancestor container is also an offset container, we found our winner\n  if (isOffsetContainer(commonAncestorContainer)) {\n    return commonAncestorContainer;\n  }\n\n  return getOffsetParent(commonAncestorContainer);\n}\n","// @flow\nexport default function microtaskDebounce(fn: Function) {\n  let pending;\n  return () => {\n    if (!pending) {\n      pending = new Promise<void>(resolve => {\n        Promise.resolve().then(() => {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}\n","// @flow\nimport type {\n  JQueryWrapper,\n  State,\n  Options,\n  Modifier,\n  Instance,\n} from './types';\n\nexport * from './types';\nexport * from './enums';\n\n// DOM Utils\nimport getCompositeRect from './dom-utils/getCompositeRect';\nimport getLayoutRect from './dom-utils/getLayoutRect';\nimport listScrollParents from './dom-utils/listScrollParents';\nimport addClientRectMargins from './dom-utils/addClientRectMargins';\nimport getCommonOffsetParent from './dom-utils/getCommonOffsetParent';\nimport unwrapVirtualElement from './dom-utils/unwrapVirtualElement';\n\n// Pure Utils\nimport unwrapJqueryElement from './utils/unwrapJqueryElement';\nimport orderModifiers from './utils/orderModifiers';\nimport debounce from './utils/debounce';\nimport validateModifiers from './utils/validateModifiers';\n\nconst INVALID_ELEMENT_ERROR =\n  'Popper: Invalid reference or popper argument provided to Popper, they must be either a valid DOM element, virtual element, or a jQuery-wrapped DOM element.';\nconst INFINITE_LOOP_ERROR =\n  'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\n\nconst areValidElements = (...args: Array<any>): boolean =>\n  !args.some(\n    element => !(element && typeof element.getBoundingClientRect === 'function')\n  );\n\nconst defaultOptionsValue: Options = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute',\n};\n\ntype PopperGeneratorArgs = {\n  defaultModifiers?: Array<Modifier<any>>,\n  defaultOptions?: $Shape<Options>,\n};\n\nexport function popperGenerator(generatorOptions: PopperGeneratorArgs = {}) {\n  const {\n    defaultModifiers = [],\n    defaultOptions = defaultOptionsValue,\n  } = generatorOptions;\n\n  return function createPopper(\n    reference: HTMLElement | JQueryWrapper,\n    popper: HTMLElement | JQueryWrapper,\n    options: $Shape<Options> = defaultOptions\n  ): Instance {\n    // Unwrap `reference` and `popper` elements in case they are\n    // wrapped by jQuery, otherwise consume them as is\n    const referenceElement = unwrapJqueryElement(reference);\n    const popperElement = unwrapJqueryElement(popper);\n\n    let state: $Shape<State> = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: { ...defaultOptionsValue, ...defaultOptions },\n      modifiersData: {},\n      elements: {\n        reference: referenceElement,\n        popper: popperElement,\n      },\n      attributes: {},\n      styles: {},\n    };\n\n    const instance = {\n      setOptions(options) {\n        // Store options into state\n        state.options = {\n          ...defaultOptions,\n          ...options,\n        };\n\n        state.scrollParents = {\n          reference: listScrollParents(referenceElement),\n          popper: listScrollParents(popperElement),\n        };\n\n        // Order `options.modifiers` so that the dependencies are fulfilled\n        // once the modifiers are executed\n        state.orderedModifiers = orderModifiers([\n          ...state.options.modifiers.filter(\n            modifier =>\n              !defaultModifiers.find(({ name }) => name === modifier.name)\n          ),\n          ...defaultModifiers.map(defaultModifier => ({\n            ...defaultModifier,\n            ...state.options.modifiers.find(\n              ({ name }) => name === defaultModifier.name\n            ),\n          })),\n        ]);\n\n        // Validate the provided modifiers so that the consumer will get warned\n        // if one of the custom modifiers is invalid for any reason\n        if (__DEV__) {\n          validateModifiers(state.orderedModifiers);\n        }\n      },\n      // Syncronous and forcefully executed update\n      // it will always be executed even if not necessary, usually NOT needed\n      // use Popper#update instead\n      forceUpdate() {\n        const {\n          reference: referenceElement,\n          popper: popperElement,\n        } = state.elements;\n        // Don't proceed if `reference` or `popper` are not valid elements anymore\n        if (!areValidElements(referenceElement, popperElement)) {\n          if (__DEV__) {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n          return;\n        }\n\n        const isFixed = state.options.strategy === 'fixed';\n\n        // Get initial measurements\n        // these are going to be used to compute the initial popper offsets\n        // and as cache for any modifier that needs them later\n        state.measures = {\n          reference: getCompositeRect(\n            referenceElement,\n            getCommonOffsetParent(\n              unwrapVirtualElement(referenceElement),\n              popperElement\n            ),\n            isFixed\n          ),\n          // CSS marginsc an be applied to popper elements to quickly\n          // apply offsets dynamically based on some CSS selectors.\n          // For this reason we include margins in this calculation.\n          popper: addClientRectMargins(\n            getLayoutRect(popperElement),\n            popperElement\n          ),\n        };\n\n        // Modifiers have the ability to read the current Popper state, included\n        // the popper offsets, and modify it to address specifc cases\n        state.reset = false;\n\n        // Cache the placement in cache to make it available to the modifiers\n        // modifiers will modify this one (rather than the one in options)\n        const prevPlacement = state.placement;\n        state.placement = state.options.placement;\n\n        state.orderedModifiers.forEach(\n          modifier =>\n            (state.modifiersData[modifier.name] = {\n              ...modifier.data,\n            })\n        );\n\n        let __debug_loops__ = 0;\n        for (let index = 0; index < state.orderedModifiers.length; index++) {\n          if (__DEV__) {\n            __debug_loops__ += 1;\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          const { fn, enabled, options = {}, name } = state.orderedModifiers[\n            index\n          ];\n\n          if (enabled && typeof fn === 'function') {\n            state = fn({ state, options, name, instance });\n          }\n        }\n\n        // Prevents a jitter if elements' size changes based on placement.\n        // This is separate from and does not solve the \"flip flicker\" issue.\n        // We can't know ahead of time (before the placement gets written to the\n        // DOM) what size the element will be due to conditionally applied/\n        // computed CSS based on placement (e.g. margins on arrow)\n        if (prevPlacement !== state.placement) {\n          instance.forceUpdate();\n        }\n      },\n\n      // Async and optimistically optimized update\n      // it will not be executed if not necessary\n      // debounced, so that it only runs at most once-per-tick\n      update: debounce(\n        () =>\n          // prettier-ignore\n          new Promise<$Shape<State>>(resolve => {\n          instance.forceUpdate();\n          resolve(state);\n        })\n      ),\n\n      destroy() {\n        // Run `onDestroy` modifier methods\n        state.orderedModifiers.forEach(\n          ({ onDestroy, enabled, name, options = {} }) =>\n            enabled &&\n            onDestroy &&\n            onDestroy({ state, name, instance, options })\n        );\n      },\n    };\n\n    // Don't proceed if `reference` or `popper` are invalid elements\n    if (!areValidElements(referenceElement, popperElement)) {\n      if (__DEV__) {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n      return instance;\n    }\n\n    instance.setOptions(options);\n\n    // Modifiers have the opportunity to execute some arbitrary code before\n    // the first update cycle is ran, the order of execution will be the same\n    // defined by the modifier dependencies directive.\n    // The `onLoad` function may add or alter the options of themselves\n    state.orderedModifiers.forEach(\n      ({ onLoad, enabled, name, options = {} }) =>\n        enabled &&\n        onLoad &&\n        (state =\n          onLoad({\n            state,\n            name,\n            instance,\n            options,\n          }) || state)\n    );\n\n    instance.update();\n\n    return instance;\n  };\n}\n\nexport const createPopper = popperGenerator();\n","// @flow\nimport type { Rect } from '../types';\n\n// Returns the layout rect of an element relative to its offsetParent. Layout\n// means it doesn't take into account transforms.\nexport default (element: HTMLElement): Rect => ({\n  x: element.offsetLeft,\n  y: element.offsetTop,\n  width: element.offsetWidth,\n  height: element.offsetHeight,\n});\n","// @flow\nimport type { ModifierArguments, Modifier } from '../types';\nimport getWindow from '../dom-utils/getWindow';\ntype Options = { scroll: boolean, resize: boolean };\n\nconst passive = { passive: true };\n\nfunction toggleEventListeners({ state, instance, scroll, resize }) {\n  if (scroll != null) {\n    const scrollParents = [\n      ...state.scrollParents.reference,\n      ...state.scrollParents.popper,\n    ];\n\n    scrollParents.forEach(scrollParent =>\n      scroll\n        ? scrollParent.addEventListener('scroll', instance.update, passive)\n        : scrollParent.removeEventListener('scroll', instance.update)\n    );\n  }\n\n  if (resize != null) {\n    const window = getWindow(state.elements.popper);\n    resize\n      ? window.addEventListener('resize', instance.update, passive)\n      : window.removeEventListener('resize', instance.update);\n  }\n}\n\nfunction onLoad({\n  state,\n  instance,\n  name,\n  options,\n}: ModifierArguments<Options>) {\n  const { scroll = true, resize = true } = options;\n\n  // cache initial options so we can compare them later\n  state.modifiersData[`${name}#persistent`] = { scroll, resize };\n\n  toggleEventListeners({ state, instance, scroll, resize });\n\n  return state;\n}\n\nfunction onDestroy({ state, instance }: ModifierArguments<Options>) {\n  toggleEventListeners({ state, instance, scroll: false, resize: false });\n}\n\nfunction update({\n  state,\n  options,\n  instance,\n  name,\n}: ModifierArguments<Options>) {\n  const data = state.modifiersData[`${name}#persistent`];\n  let { scroll = true, resize = true } = options;\n\n  // set options to `null` if they didn't change, so we know not to run any logic\n  if (data.scroll === scroll) {\n    scroll = null;\n  }\n  if (data.resize === resize) {\n    resize = null;\n  }\n\n  // Update cache\n  state.modifiersData[`${name}#persistent`] = { scroll, resize };\n\n  toggleEventListeners({ state, instance, scroll, resize });\n\n  return state;\n}\n\nexport default ({\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: update,\n  onLoad,\n  onDestroy,\n  data: {},\n}: Modifier<Options>);\n","// @flow\nexport const top: 'top' = 'top';\nexport const bottom: 'bottom' = 'bottom';\nexport const right: 'right' = 'right';\nexport const left: 'left' = 'left';\nexport const auto: 'auto' = 'auto';\nexport type BasePlacement =\n  | typeof top\n  | typeof bottom\n  | typeof right\n  | typeof left;\nexport const basePlacements: Array<BasePlacement> = [top, bottom, right, left];\n\nexport const start: 'start' = 'start';\nexport const end: 'end' = 'end';\nexport type VariationPlacement = typeof start | typeof end;\n\nexport const center: 'center' = 'center';\nexport const edges: 'edges' = 'edges';\nexport const surfaces: 'surfaces' = 'surfaces';\nexport type Tether = false | typeof center | typeof edges | typeof surfaces;\n\nexport const clippingParents: 'clippingParents' = 'clippingParents';\nexport const viewport: 'viewport' = 'viewport';\nexport type OverflowArea =\n  | HTMLElement\n  | typeof clippingParents\n  | typeof viewport;\nexport type RootOverflowArea = typeof viewport | 'document';\n\nexport const popper: 'popper' = 'popper';\nexport const reference: 'reference' = 'reference';\nexport type Context = typeof popper | typeof reference;\n\nexport type Placement =\n  | 'auto'\n  | 'auto-start'\n  | 'auto-end'\n  | 'top'\n  | 'top-start'\n  | 'top-end'\n  | 'bottom'\n  | 'bottom-start'\n  | 'bottom-end'\n  | 'right'\n  | 'right-start'\n  | 'right-end'\n  | 'left'\n  | 'left-start'\n  | 'left-end';\n\nexport const placements: Array<Placement> = basePlacements.reduce(\n  (acc: Array<Placement>, placement: BasePlacement): Array<Placement> =>\n    acc.concat([\n      placement,\n      (`${placement}-${start}`: any),\n      (`${placement}-${end}`: any),\n    ]),\n  []\n);\n\n// modifiers that need to read the DOM\nexport const beforeRead: 'beforeRead' = 'beforeRead';\nexport const read: 'read' = 'read';\nexport const afterRead: 'afterRead' = 'afterRead';\n// pure-logic modifiers\nexport const beforeMain: 'beforeMain' = 'beforeMain';\nexport const main: 'main' = 'main';\nexport const afterMain: 'afterMain' = 'afterMain';\n// modifier with the purpose to write to the DOM (or write into a framework state)\nexport const beforeWrite: 'beforeWrite' = 'beforeWrite';\nexport const write: 'write' = 'write';\nexport const afterWrite: 'afterWrite' = 'afterWrite';\nexport const modifierPhases: Array<ModifierPhases> = [\n  beforeRead,\n  read,\n  afterRead,\n  beforeMain,\n  main,\n  afterMain,\n  beforeWrite,\n  write,\n  afterWrite,\n];\n\nexport type ModifierPhases =\n  | typeof beforeRead\n  | typeof read\n  | typeof afterRead\n  | typeof beforeMain\n  | typeof main\n  | typeof afterMain\n  | typeof beforeWrite\n  | typeof write\n  | typeof afterWrite;\n","// @flow\nimport type { ClientRectObject, VirtualElement } from '../types';\n\nexport default (element: Element | VirtualElement): ClientRectObject => {\n  const rect = JSON.parse(JSON.stringify(element.getBoundingClientRect()));\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n};\n","// @flow\nimport type { VirtualElement } from '../types';\nimport { isElement } from './instanceOf';\n\nexport default (element: Element | VirtualElement): Element => {\n  return isElement(element) ? element : element.contextElement;\n};\n","// @flow\nimport type { Rect, VirtualElement } from '../types';\nimport getBoundingClientRect from './getBoundingClientRect';\nimport getScrollSum from './getScrollSum';\nimport unwrapVirtualElement from './unwrapVirtualElement';\nimport { isElement } from './instanceOf';\n\n// Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\nexport default (\n  elementOrVirtualElement: Element | VirtualElement,\n  commonOffsetParent: Element,\n  isFixed: boolean = false\n): Rect => {\n  const element = unwrapVirtualElement(elementOrVirtualElement);\n  const rect = getBoundingClientRect(element);\n  const offsetParentRect =\n    isElement(commonOffsetParent) && !isFixed\n      ? getBoundingClientRect(commonOffsetParent)\n      : { left: 0, top: 0 };\n  const offsetParentScrollSum = getScrollSum(\n    isFixed ? [] : [commonOffsetParent]\n  );\n\n  const width = rect.width;\n  const height = rect.height;\n  const x =\n    rect.left + offsetParentScrollSum.scrollLeft - offsetParentRect.left;\n  const y = rect.top + offsetParentScrollSum.scrollTop - offsetParentRect.top;\n\n  return { width, height, x, y };\n};\n","// @flow\nimport getNodeScroll from './getNodeScroll';\n\nexport default (scrollParents: Array<Element>) =>\n  scrollParents.reduce(\n    (scroll, scrollParent) => {\n      const nodeScroll = getNodeScroll(scrollParent);\n      scroll.scrollTop += nodeScroll.scrollTop;\n      scroll.scrollLeft += nodeScroll.scrollLeft;\n      return scroll;\n    },\n    { scrollTop: 0, scrollLeft: 0 }\n  );\n","// @flow\nimport getWindowScroll from './getWindowScroll';\nimport getWindow from './getWindow';\nimport { isHTMLElement } from './instanceOf';\nimport getHTMLElementScroll from './getHTMLElementScroll';\n\nexport default function getNodeScroll(node: Node) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}\n","// @flow\n\nexport default function getHTMLElementScroll(element: HTMLElement) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop,\n  };\n}\n","// @flow\nimport getWindow from './getWindow';\n\nexport default function getWindowScroll(node: Node) {\n  const win = getWindow(node);\n  const scrollLeft = win.pageXOffset;\n  const scrollTop = win.pageYOffset;\n  return { scrollLeft, scrollTop };\n}\n","// @flow\n\nexport default (element: ?Node): ?string =>\n  element ? (element.nodeName || '').toLowerCase() : null;\n","// @flow\nimport getNodeName from './getNodeName';\n\nexport default (element: Node | ShadowRoot): Node => {\n  if (getNodeName(element) === 'html') {\n    // DocumentElement detectedF\n    return element;\n  }\n  return (\n    element.parentNode || // DOM Element detected\n    // $FlowFixMe: need a better way to handle this...\n    element.host || // ShadowRoot detected\n    document.ownerDocument || // Fallback to ownerDocument if available\n    document.documentElement // Or to documentElement if everything else fails\n  );\n};\n","// @flow\nimport type { Rect } from '../types';\nimport getElementMargins from './getElementMargins';\n\nexport default (rect: Rect, element: HTMLElement): Rect => {\n  const margins = getElementMargins(element);\n\n  return {\n    width: rect.width + margins.left + margins.right,\n    height: rect.height + margins.top + margins.bottom,\n    y: rect.y - margins.top,\n    x: rect.x - margins.left,\n  };\n};\n","// @flow\nimport getComputedStyle from './getComputedStyle';\n\nexport default (element: HTMLElement) => {\n  // get the element margins, we need them to properly align the popper\n  const styles = getComputedStyle(element);\n\n  const top = parseFloat(styles.marginTop) || 0;\n  const right = parseFloat(styles.marginRight) || 0;\n  const bottom = parseFloat(styles.marginBottom) || 0;\n  const left = parseFloat(styles.marginLeft) || 0;\n\n  return { top, right, bottom, left };\n};\n","// @flow\nimport type { JQueryWrapper } from '../types';\n\nexport default (element: HTMLElement | JQueryWrapper): HTMLElement =>\n  // $FlowFixMe: need to get type refinement work\n  element.hasOwnProperty('jquery') ? element[0] : element;\n","// @flow\nimport type { Modifier } from '../types';\nimport { modifierPhases } from '../enums';\n\n// source: https://stackoverflow.com/questions/49875255\nconst order = modifiers => {\n  const map = new Map();\n  const visited = new Set();\n  const result = [];\n\n  modifiers.forEach(modifier => {\n    map.set(modifier.name, modifier);\n  });\n\n  // On visiting object, check for its dependencies and visit them recursively\n  function sort(modifier: Modifier<any>) {\n    visited.add(modifier.name);\n\n    const requires = [\n      ...(modifier.requires || []),\n      ...(modifier.optionallyRequires || []),\n    ];\n\n    requires.forEach(dep => {\n      if (!visited.has(dep)) {\n        const depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n\n    result.push(modifier);\n  }\n\n  modifiers.forEach(modifier => {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n\n  return result;\n};\n\nexport default (modifiers: Array<Modifier<any>>): Array<Modifier<any>> => {\n  // order based on dependencies\n  const orderedModifiers = order(modifiers);\n\n  // order based on phase\n  return modifierPhases.reduce((acc, phase) => {\n    return acc.concat(\n      orderedModifiers.filter(modifier => modifier.phase === phase)\n    );\n  }, []);\n};\n","// @flow\nimport type {\n  PositioningStrategy,\n  Offsets,\n  Modifier,\n  ModifierArguments,\n} from '../types';\n\n// This modifier takes the Popper state and prepares some StyleSheet properties\n// that can be applied to the popper element to make it render in the expected position.\n\ntype Options = {\n  gpuAcceleration?: boolean,\n};\n\n// Round the offsets to the nearest suitable subpixel based on the DPR\nconst roundOffsets = ({ x, y }) => {\n  const dpr = window.devicePixelRatio;\n  return {\n    x: Math.round(x * dpr) / dpr || 0,\n    y: Math.round(y * dpr) / dpr || 0,\n  };\n};\n\nexport const mapToStyles = ({\n  offsets,\n  position,\n  gpuAcceleration,\n}: {\n  offsets: Offsets,\n  position: PositioningStrategy,\n  gpuAcceleration: boolean,\n}) => {\n  const { x, y } = roundOffsets(offsets);\n  const hasX = offsets.hasOwnProperty('x');\n  const hasY = offsets.hasOwnProperty('y');\n\n  // Layer acceleration can disable subpixel rendering which causes slightly\n  // blurry text on low PPI displays.\n  // Zooming can change the DPR, but it seems to report a value that will\n  // cleanly divide the values into the appropriate subpixels.\n  if (gpuAcceleration === false || window.devicePixelRatio < 2) {\n    return {\n      top: hasY ? `${y}px` : '',\n      left: hasX ? `${x}px` : '',\n      transform: '',\n      position,\n    };\n  } else {\n    return {\n      top: hasY ? '0' : '',\n      left: hasX ? '0' : '',\n      transform: `translate3d(${x}px, ${y}px, 0)`,\n      position,\n    };\n  }\n};\n\nfunction computeStyles({ state, options }: ModifierArguments<Options>) {\n  const { gpuAcceleration = true } = options;\n\n  // popper offsets are always available\n  state.styles.popper = {\n    ...state.styles.popper,\n    ...mapToStyles({\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      gpuAcceleration,\n    }),\n  };\n\n  // arrow offsets may not be available\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = {\n      ...state.styles.arrow,\n      ...mapToStyles({\n        offsets: state.modifiersData.arrow,\n        position: 'absolute',\n        gpuAcceleration,\n      }),\n    };\n  }\n\n  state.attributes.popper = {\n    ...state.attributes.popper,\n    'data-popper-placement': state.placement,\n  };\n\n  return state;\n}\n\nexport default ({\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'afterMain',\n  fn: computeStyles,\n  data: {},\n}: Modifier<Options>);\n","// @flow\nimport { popperGenerator } from './index';\nimport eventListeners from './modifiers/eventListeners';\nimport popperOffsets from './modifiers/popperOffsets';\nimport computeStyles from './modifiers/computeStyles';\nimport applyStyles from './modifiers/applyStyles';\n\nconst createPopper = popperGenerator({\n  defaultModifiers: [eventListeners, popperOffsets, computeStyles, applyStyles],\n});\n\n// eslint-disable-next-line import/no-unused-modules\nexport { createPopper, popperGenerator };\n","// @flow\nimport type { ModifierArguments, Modifier } from '../types';\nimport computeOffsets from '../utils/computeOffsets';\n\nfunction popperOffsets({ state, name }: ModifierArguments<{||}>) {\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = computeOffsets({\n    reference: state.measures.reference,\n    element: state.measures.popper,\n    strategy: 'absolute',\n    placement: state.placement,\n  });\n\n  return state;\n}\n\nexport default ({\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets,\n  data: {},\n}: Modifier<{||}>);\n","// @flow\nimport getBasePlacement from './getBasePlacement';\nimport getVariationPlacement from './getVariationPlacement';\nimport getMainAxisFromPlacement from './getMainAxisFromPlacement';\nimport type {\n  Rect,\n  PositioningStrategy,\n  Offsets,\n  ClientRectObject,\n} from '../types';\nimport { top, right, bottom, left, start, end, type Placement } from '../enums';\n\nexport default ({\n  reference,\n  element,\n  placement,\n}: {\n  reference: Rect | ClientRectObject,\n  element: Rect | ClientRectObject,\n  strategy: PositioningStrategy,\n  placement?: Placement,\n}): Offsets => {\n  const basePlacement = placement ? getBasePlacement(placement) : null;\n  const variationPlacement = placement\n    ? getVariationPlacement(placement)\n    : null;\n\n  let offsets;\n  switch (basePlacement) {\n    case top:\n      offsets = {\n        x: reference.x + reference.width / 2 - element.width / 2,\n        y: reference.y - element.height,\n      };\n      break;\n    case bottom:\n      offsets = {\n        x: reference.x + reference.width / 2 - element.width / 2,\n        y: reference.y + reference.height,\n      };\n      break;\n    case right:\n      offsets = {\n        x: reference.x + reference.width,\n        y: reference.y + reference.height / 2 - element.height / 2,\n      };\n      break;\n    case left:\n      offsets = {\n        x: reference.x - element.width,\n        y: reference.y + reference.height / 2 - element.height / 2,\n      };\n      break;\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y,\n      };\n  }\n\n  const mainAxis = basePlacement\n    ? getMainAxisFromPlacement(basePlacement)\n    : null;\n\n  if (mainAxis != null) {\n    const len = mainAxis === 'y' ? 'height' : 'width';\n\n    switch (variationPlacement) {\n      case start:\n        offsets[mainAxis] =\n          Math.floor(offsets[mainAxis]) -\n          Math.floor(reference[len] / 2 - element[len] / 2);\n        break;\n      case end:\n        offsets[mainAxis] =\n          Math.floor(offsets[mainAxis]) +\n          Math.ceil(reference[len] / 2 - element[len] / 2);\n        break;\n      default:\n    }\n  }\n\n  return offsets;\n};\n","// @flow\nimport { type BasePlacement, type Placement, auto } from '../enums';\n\nexport default (placement: Placement | typeof auto): BasePlacement =>\n  (placement.split('-')[0]: any);\n","// @flow\nimport { type VariationPlacement, type Placement, auto } from '../enums';\n\nexport default (placement: Placement | typeof auto): ?VariationPlacement =>\n  (placement.split('-')[1]: any);\n","// @flow\nimport type { Placement } from '../enums';\nexport default (placement: Placement): 'x' | 'y' =>\n  ['top', 'bottom'].includes(placement) ? 'x' : 'y';\n","// @flow\nimport type { Modifier, ModifierArguments } from '../types';\nimport getNodeName from '../dom-utils/getNodeName';\nimport { isHTMLElement } from '../dom-utils/instanceOf';\n\n// This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles({ state }: ModifierArguments<{||}>) {\n  Object.keys(state.elements).forEach(name => {\n    const style = state.styles[name] || {};\n\n    const attributes = state.attributes[name] || {};\n    const element = state.elements[name];\n\n    // arrow is optional + virtual elements\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    }\n\n    // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe\n    Object.assign(element.style, style);\n\n    Object.entries(attributes).forEach(([name, value]: [string, any]) => {\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n\n  return state;\n}\n\nfunction onDestroy({ state }: ModifierArguments<{||}>) {\n  Object.keys(state.elements).forEach(name => {\n    const element = state.elements[name];\n    const styleProperties = Object.keys(\n      state.styles.hasOwnProperty(name) ? { ...state.styles[name] } : {}\n    );\n    const attributes = state.attributes[name] || {};\n\n    // Set all values to an empty string to unset them\n    const style = styleProperties.reduce(\n      (style, property) => ({\n        ...style,\n        [String(property)]: '',\n      }),\n      {}\n    );\n\n    // arrow is optional + virtual elements\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    }\n\n    // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe\n    Object.assign(element.style, style);\n\n    Object.keys(attributes).forEach(attribute =>\n      element.removeAttribute(attribute)\n    );\n  });\n}\n\nexport default ({\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  onDestroy,\n  requires: ['computeStyles'],\n}: Modifier<{||}>);\n"],"names":["getWindow","node","ownerDocument","window","isElement","isHTMLElement","isShadowRoot","getComputedStyle","element","listScrollParents","list","scrollParent","getScrollParent","getNodeName","getParentNode","isBody","target","updatedList","getOffsetParent","offsetParent","getTrueOffsetParent","getRoot","parentNode","getCommonOffsetParent","element1","element2","element1root","element2root","order","Node","document","start","end","range","firstElementChild","commonAncestorContainer","microtaskDebounce","fn","pending","Promise","resolve","undefined","popperGenerator","generatorOptions","defaultModifiers","defaultOptions","defaultOptionsValue","reference","popper","options","referenceElement","unwrapJqueryElement","popperElement","state","placement","orderedModifiers","modifiersData","elements","attributes","styles","instance","setOptions","orderModifiers","modifier","defaultModifier","forceUpdate","areValidElements","isFixed","getCompositeRect","unwrapVirtualElement","addClientRectMargins","x","y","width","height","index","name","prevPlacement","update","debounce","destroy","onDestroy","onLoad","toggleEventListeners","scroll","passive","resize","basePlacements","top","bottom","right","left","acc","modifierPhases","getBoundingClientRect","rect","JSON","elementOrVirtualElement","commonOffsetParent","offsetParentRect","getScrollSum","scrollParents","getHTMLElementScroll","scrollLeft","scrollTop","win","getWindowScroll","nodeScroll","offsetParentScrollSum","parseFloat","modifiers","map","Map","visited","Set","result","dep","depModifier","sort","phase","args","strategy","mapToStyles","offsets","position","gpuAcceleration","dpr","Math","hasX","hasY","transform","createPopper","eventListeners","enabled","data","popperOffsets$1","popperOffsets","basePlacement","mainAxis","len","variationPlacement","computeStyles$1","computeStyles","applyStyles$1","applyStyles","style","Object","value","onDestroy$1","styleProperties","property","String","attribute","requires"],"mappings":"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"}