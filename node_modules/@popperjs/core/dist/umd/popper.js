/**
 * @popperjs/core v2.0.0-alpha.1
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.Popper = {}));
}(this, (function (exports) { 'use strict';

  var top = 'top';
  var bottom = 'bottom';
  var right = 'right';
  var left = 'left';
  var basePlacements = [top, bottom, right, left];
  var start = 'start';
  var end = 'end';
  var center = 'center';
  var edges = 'edges';
  var surfaces = 'surfaces';
  var clippingParents = 'clippingParents';
  var viewport = 'viewport';
  var popper = 'popper';
  var reference = 'reference';
  var placements = basePlacements.reduce(function (acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []); // modifiers that need to read the DOM

  var beforeRead = 'beforeRead';
  var read = 'read';
  var afterRead = 'afterRead'; // pure-logic modifiers

  var beforeMain = 'beforeMain';
  var main = 'main';
  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

  var beforeWrite = 'beforeWrite';
  var write = 'write';
  var afterWrite = 'afterWrite';
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  var getBoundingClientRect = (function (element) {
    var rect = JSON.parse(JSON.stringify(element.getBoundingClientRect()));
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  });

  function getWindow(node) {
    var ownerDocument = node != null && typeof node === 'object' && node.hasOwnProperty('ownerDocument') ? // $FlowFixMe: assume ownerDocument to be the one we are looking for
    node.ownerDocument : null;
    return ownerDocument != null ? ownerDocument.defaultView : window;
  }

  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft: scrollLeft,
      scrollTop: scrollTop
    };
  }

  /*:: declare function isElement(node: mixed): boolean %checks(node instanceof
    Element); */

  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement;
  }
  /*:: declare function isHTMLElement(node: mixed): boolean %checks(node instanceof
    HTMLElement); */


  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement;
  }
  /*:: declare function isShadowRoot(node: mixed): boolean %checks(node instanceof
    ShadowRoot); */


  function isShadowRoot(node) {
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement;
  }

  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  var getScrollSum = (function (scrollParents) {
    return scrollParents.reduce(function (scroll, scrollParent) {
      var nodeScroll = getNodeScroll(scrollParent);
      scroll.scrollTop += nodeScroll.scrollTop;
      scroll.scrollLeft += nodeScroll.scrollLeft;
      return scroll;
    }, {
      scrollTop: 0,
      scrollLeft: 0
    });
  });

  var unwrapVirtualElement = (function (element) {
    return isElement(element) ? element : element.contextElement;
  });

  // Composite means it takes into account transforms as well as layout.

  var getCompositeRect = (function (elementOrVirtualElement, commonOffsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }

    var element = unwrapVirtualElement(elementOrVirtualElement);
    var rect = getBoundingClientRect(element);
    var offsetParentRect = isElement(commonOffsetParent) && !isFixed ? getBoundingClientRect(commonOffsetParent) : {
      left: 0,
      top: 0
    };
    var offsetParentScrollSum = getScrollSum(isFixed ? [] : [commonOffsetParent]);
    var width = rect.width;
    var height = rect.height;
    var x = rect.left + offsetParentScrollSum.scrollLeft - offsetParentRect.left;
    var y = rect.top + offsetParentScrollSum.scrollTop - offsetParentRect.top;
    return {
      width: width,
      height: height,
      x: x,
      y: y
    };
  });

  // Returns the layout rect of an element relative to its offsetParent. Layout
  // means it doesn't take into account transforms.
  var getLayoutRect = (function (element) {
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  });

  var getNodeName = (function (element) {
    return element ? (element.nodeName || '').toLowerCase() : null;
  });

  var getParentNode = (function (element) {
    if (getNodeName(element) === 'html') {
      // DocumentElement detectedF
      return element;
    }

    return element.parentNode || // DOM Element detected
    // $FlowFixMe: need a better way to handle this...
    element.host || // ShadowRoot detected
    document.ownerDocument || // Fallback to ownerDocument if available
    document.documentElement // Or to documentElement if everything else fails
    ;
  });

  function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
  }

  function getScrollParent(node) {
    if (['html', 'body', '#document'].includes(getNodeName(node))) {
      return node.ownerDocument.body;
    }

    if (isHTMLElement(node)) {
      // Firefox want us to check `-x` and `-y` variations as well
      var _getComputedStyle = getComputedStyle(node),
          overflow = _getComputedStyle.overflow,
          overflowX = _getComputedStyle.overflowX,
          overflowY = _getComputedStyle.overflowY;

      if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
        return node;
      }
    }

    return getScrollParent(getParentNode(node));
  }

  function listScrollParents(element, list) {
    if (list === void 0) {
      list = [];
    }

    var scrollParent = getScrollParent(element);
    var isBody = getNodeName(scrollParent) === 'body';
    var target = isBody ? getWindow(scrollParent) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
  }

  var getElementMargins = (function (element) {
    // get the element margins, we need them to properly align the popper
    var styles = getComputedStyle(element);
    var top = parseFloat(styles.marginTop) || 0;
    var right = parseFloat(styles.marginRight) || 0;
    var bottom = parseFloat(styles.marginBottom) || 0;
    var left = parseFloat(styles.marginLeft) || 0;
    return {
      top: top,
      right: right,
      bottom: bottom,
      left: left
    };
  });

  var addClientRectMargins = (function (rect, element) {
    var margins = getElementMargins(element);
    return {
      width: rect.width + margins.left + margins.right,
      height: rect.height + margins.top + margins.bottom,
      y: rect.y - margins.top,
      x: rect.x - margins.left
    };
  });

  var isTableElement = (function (element) {
    return ['table', 'td', 'th'].includes(getNodeName(element));
  });

  var getTrueOffsetParent = function getTrueOffsetParent(element) {
    return isHTMLElement(element) ? element.offsetParent : null;
  };

  function getOffsetParent(element) {
    var window = getWindow(element);
    var offsetParent = getTrueOffsetParent(element); // Find the nearest non-table offsetParent

    while (offsetParent && isTableElement(offsetParent)) {
      offsetParent = getTrueOffsetParent(offsetParent);
    }

    if (offsetParent && getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static') {
      return window;
    }

    return offsetParent || window;
  }

  function isOffsetContainer(element) {
    var firstElementChild = element.firstElementChild;
    return !firstElementChild || getOffsetParent(firstElementChild) === element;
  }

  function getRoot(node) {
    var parentNode = node.parentNode;

    if (parentNode != null) {
      return getRoot(parentNode);
    }

    return node;
  }

  function getCommonOffsetParent(element1, element2) {
    // If one of the nodes is inside shadowDOM, find which one
    var element1root = getRoot(element1);
    var element2root = getRoot(element2);

    if (isShadowRoot(element1root)) {
      return getCommonOffsetParent(element1root.host, element2);
    } else if (isShadowRoot(element2root)) {
      return getCommonOffsetParent(element1, element2root.host);
    } // Here we make sure to give as "start" the element that comes first in the DOM


    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
    var start = order ? element1 : element2;
    var end = order ? element2 : element1; // Both nodes are inside #document
    // Get common ancestor container

    var range = document.createRange();
    range.setStart(start, 0);
    range.setEnd(end, 0);
    var commonAncestorContainer = range.commonAncestorContainer; // If ancestor container is not an element, we must return a safe
    // fallback, body is a good bet

    if (!isElement(commonAncestorContainer)) {
      return getWindow(commonAncestorContainer).body;
    } // if ancestor container is also an offset container, we found our winner


    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  var unwrapJqueryElement = (function (element) {
    return (// $FlowFixMe: need to get type refinement work
      element.hasOwnProperty('jquery') ? element[0] : element
    );
  });

  var order = function order(modifiers) {
    var map = new Map();
    var visited = new Set();
    var result = [];
    modifiers.forEach(function (modifier) {
      map.set(modifier.name, modifier);
    }); // On visiting object, check for its dependencies and visit them recursively

    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.optionallyRequires || []);
      requires.forEach(function (dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);

          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }

    modifiers.forEach(function (modifier) {
      if (!visited.has(modifier.name)) {
        // check for visited object
        sort(modifier);
      }
    });
    return result;
  };

  var orderModifiers = (function (modifiers) {
    // order based on dependencies
    var orderedModifiers = order(modifiers); // order based on phase

    return modifierPhases.reduce(function (acc, phase) {
      return acc.concat(orderedModifiers.filter(function (modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  });

  function microtaskDebounce(fn) {
    var pending;
    return function () {
      if (!pending) {
        pending = new Promise(function (resolve) {
          Promise.resolve().then(function () {
            pending = undefined;
            resolve(fn());
          });
        });
      }

      return pending;
    };
  }

  var format = (function (str) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return [].concat(args).reduce(function (p, c) {
      return p.replace(/%s/, c);
    }, str);
  });

  var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
  var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
  var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'onLoad', 'requires', 'options'];
  var validateModifiers = (function (modifiers) {
    modifiers.forEach(function (modifier) {
      Object.keys(modifier).forEach(function (key) {
        switch (key) {
          case 'name':
            if (typeof modifier.name !== 'string') {
              console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
            }

            break;

          case 'enabled':
            if (typeof modifier.enabled !== 'boolean') {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
            }

          case 'phase':
            if (!modifierPhases.includes(modifier.phase)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
            }

            break;

          case 'fn':
            if (typeof modifier.fn !== 'function') {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
            }

            break;

          case 'onLoad':
            if (typeof modifier.onLoad !== 'function') {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"onLoad"', '"function"', "\"" + String(modifier.fn) + "\""));
            }

            break;

          case 'onDestroy':
            if (typeof modifier.onDestroy !== 'function') {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"onDestroy"', '"function"', "\"" + String(modifier.fn) + "\""));
            }

            break;

          case 'requires':
            if (!Array.isArray(modifier.requires)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
            }

            break;

          case 'optionallyRequires':
            if (!Array.isArray(modifier.requires)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
            }

            break;

          case 'options':
          case 'data':
            break;

          default:
            console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
              return "\"" + s + "\"";
            }).join(', ') + "; but \"" + key + "\" was provided.");
        }

        modifier.requires && modifier.requires.forEach(function (requirement) {
          if (modifiers.find(function (mod) {
            return mod.name === requirement;
          }) == null) {
            console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
          }
        });
      });
    });
  });

  var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided to Popper, they must be either a valid DOM element, virtual element, or a jQuery-wrapped DOM element.';
  var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';

  var areValidElements = function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return !args.some(function (element) {
      return !(element && typeof element.getBoundingClientRect === 'function');
    });
  };

  var defaultOptionsValue = {
    placement: 'bottom',
    modifiers: [],
    strategy: 'absolute'
  };
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }

    var _generatorOptions = generatorOptions,
        _generatorOptions$def = _generatorOptions.defaultModifiers,
        defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
        _generatorOptions$def2 = _generatorOptions.defaultOptions,
        defaultOptions = _generatorOptions$def2 === void 0 ? defaultOptionsValue : _generatorOptions$def2;
    return function createPopper(reference, popper, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      // Unwrap `reference` and `popper` elements in case they are
      // wrapped by jQuery, otherwise consume them as is
      var referenceElement = unwrapJqueryElement(reference);
      var popperElement = unwrapJqueryElement(popper);
      var state = {
        placement: 'bottom',
        orderedModifiers: [],
        options: Object.assign({}, defaultOptionsValue, {}, defaultOptions),
        modifiersData: {},
        elements: {
          reference: referenceElement,
          popper: popperElement
        },
        attributes: {},
        styles: {}
      };
      var instance = {
        setOptions: function setOptions(options) {
          // Store options into state
          state.options = Object.assign({}, defaultOptions, {}, options);
          state.scrollParents = {
            reference: listScrollParents(referenceElement),
            popper: listScrollParents(popperElement)
          }; // Order `options.modifiers` so that the dependencies are fulfilled
          // once the modifiers are executed

          state.orderedModifiers = orderModifiers([].concat(state.options.modifiers.filter(function (modifier) {
            return !defaultModifiers.find(function (_ref) {
              var name = _ref.name;
              return name === modifier.name;
            });
          }), defaultModifiers.map(function (defaultModifier) {
            return Object.assign({}, defaultModifier, {}, state.options.modifiers.find(function (_ref2) {
              var name = _ref2.name;
              return name === defaultModifier.name;
            }));
          }))); // Validate the provided modifiers so that the consumer will get warned
          // if one of the custom modifiers is invalid for any reason

          {
            validateModifiers(state.orderedModifiers);
          }
        },
        // Syncronous and forcefully executed update
        // it will always be executed even if not necessary, usually NOT needed
        // use Popper#update instead
        forceUpdate: function forceUpdate() {
          var _state$elements = state.elements,
              referenceElement = _state$elements.reference,
              popperElement = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements anymore

          if (!areValidElements(referenceElement, popperElement)) {
            {
              console.error(INVALID_ELEMENT_ERROR);
            }

            return;
          }

          var isFixed = state.options.strategy === 'fixed'; // Get initial measurements
          // these are going to be used to compute the initial popper offsets
          // and as cache for any modifier that needs them later

          state.measures = {
            reference: getCompositeRect(referenceElement, getCommonOffsetParent(unwrapVirtualElement(referenceElement), popperElement), isFixed),
            // CSS marginsc an be applied to popper elements to quickly
            // apply offsets dynamically based on some CSS selectors.
            // For this reason we include margins in this calculation.
            popper: addClientRectMargins(getLayoutRect(popperElement), popperElement)
          }; // Modifiers have the ability to read the current Popper state, included
          // the popper offsets, and modify it to address specifc cases

          state.reset = false; // Cache the placement in cache to make it available to the modifiers
          // modifiers will modify this one (rather than the one in options)

          var prevPlacement = state.placement;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function (modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          var __debug_loops__ = 0;

          for (var index = 0; index < state.orderedModifiers.length; index++) {
            {
              __debug_loops__ += 1;

              if (__debug_loops__ > 100) {
                console.error(INFINITE_LOOP_ERROR);
                break;
              }
            }

            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }

            var _state$orderedModifie = state.orderedModifiers[index],
                fn = _state$orderedModifie.fn,
                enabled = _state$orderedModifie.enabled,
                _state$orderedModifie2 = _state$orderedModifie.options,
                _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                name = _state$orderedModifie.name;

            if (enabled && typeof fn === 'function') {
              state = fn({
                state: state,
                options: _options,
                name: name,
                instance: instance
              });
            }
          } // Prevents a jitter if elements' size changes based on placement.
          // This is separate from and does not solve the "flip flicker" issue.
          // We can't know ahead of time (before the placement gets written to the
          // DOM) what size the element will be due to conditionally applied/
          // computed CSS based on placement (e.g. margins on arrow)


          if (prevPlacement !== state.placement) {
            instance.forceUpdate();
          }
        },
        // Async and optimistically optimized update
        // it will not be executed if not necessary
        // debounced, so that it only runs at most once-per-tick
        update: microtaskDebounce(function () {
          return (// prettier-ignore
            new Promise(function (resolve) {
              instance.forceUpdate();
              resolve(state);
            })
          );
        }),
        destroy: function destroy() {
          // Run `onDestroy` modifier methods
          state.orderedModifiers.forEach(function (_ref3) {
            var onDestroy = _ref3.onDestroy,
                enabled = _ref3.enabled,
                name = _ref3.name,
                _ref3$options = _ref3.options,
                options = _ref3$options === void 0 ? {} : _ref3$options;
            return enabled && onDestroy && onDestroy({
              state: state,
              name: name,
              instance: instance,
              options: options
            });
          });
        }
      }; // Don't proceed if `reference` or `popper` are invalid elements

      if (!areValidElements(referenceElement, popperElement)) {
        {
          console.error(INVALID_ELEMENT_ERROR);
        }

        return instance;
      }

      instance.setOptions(options); // Modifiers have the opportunity to execute some arbitrary code before
      // the first update cycle is ran, the order of execution will be the same
      // defined by the modifier dependencies directive.
      // The `onLoad` function may add or alter the options of themselves

      state.orderedModifiers.forEach(function (_ref4) {
        var onLoad = _ref4.onLoad,
            enabled = _ref4.enabled,
            name = _ref4.name,
            _ref4$options = _ref4.options,
            options = _ref4$options === void 0 ? {} : _ref4$options;
        return enabled && onLoad && (state = onLoad({
          state: state,
          name: name,
          instance: instance,
          options: options
        }) || state);
      });
      instance.update();
      return instance;
    };
  }
  var createPopper = popperGenerator();

  var passive = {
    passive: true
  };

  function toggleEventListeners(_ref) {
    var state = _ref.state,
        instance = _ref.instance,
        scroll = _ref.scroll,
        resize = _ref.resize;

    if (scroll != null) {
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
      scrollParents.forEach(function (scrollParent) {
        return scroll ? scrollParent.addEventListener('scroll', instance.update, passive) : scrollParent.removeEventListener('scroll', instance.update);
      });
    }

    if (resize != null) {
      var window = getWindow(state.elements.popper);
      resize ? window.addEventListener('resize', instance.update, passive) : window.removeEventListener('resize', instance.update);
    }
  }

  function onLoad(_ref2) {
    var state = _ref2.state,
        instance = _ref2.instance,
        name = _ref2.name,
        options = _ref2.options;
    var _options$scroll = options.scroll,
        scroll = _options$scroll === void 0 ? true : _options$scroll,
        _options$resize = options.resize,
        resize = _options$resize === void 0 ? true : _options$resize; // cache initial options so we can compare them later

    state.modifiersData[name + "#persistent"] = {
      scroll: scroll,
      resize: resize
    };
    toggleEventListeners({
      state: state,
      instance: instance,
      scroll: scroll,
      resize: resize
    });
    return state;
  }

  function onDestroy(_ref3) {
    var state = _ref3.state,
        instance = _ref3.instance;
    toggleEventListeners({
      state: state,
      instance: instance,
      scroll: false,
      resize: false
    });
  }

  function update(_ref4) {
    var state = _ref4.state,
        options = _ref4.options,
        instance = _ref4.instance,
        name = _ref4.name;
    var data = state.modifiersData[name + "#persistent"];
    var _options$scroll2 = options.scroll,
        scroll = _options$scroll2 === void 0 ? true : _options$scroll2,
        _options$resize2 = options.resize,
        resize = _options$resize2 === void 0 ? true : _options$resize2; // set options to `null` if they didn't change, so we know not to run any logic

    if (data.scroll === scroll) {
      scroll = null;
    }

    if (data.resize === resize) {
      resize = null;
    } // Update cache


    state.modifiersData[name + "#persistent"] = {
      scroll: scroll,
      resize: resize
    };
    toggleEventListeners({
      state: state,
      instance: instance,
      scroll: scroll,
      resize: resize
    });
    return state;
  }

  var eventListeners = {
    name: 'eventListeners',
    enabled: true,
    phase: 'write',
    fn: update,
    onLoad: onLoad,
    onDestroy: onDestroy,
    data: {}
  };

  var getBasePlacement = (function (placement) {
    return placement.split('-')[0];
  });

  var getVariationPlacement = (function (placement) {
    return placement.split('-')[1];
  });

  var getMainAxisFromPlacement = (function (placement) {
    return ['top', 'bottom'].includes(placement) ? 'x' : 'y';
  });

  var computeOffsets = (function (_ref) {
    var reference = _ref.reference,
        element = _ref.element,
        placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variationPlacement = placement ? getVariationPlacement(placement) : null;
    var offsets;

    switch (basePlacement) {
      case top:
        offsets = {
          x: reference.x + reference.width / 2 - element.width / 2,
          y: reference.y - element.height
        };
        break;

      case bottom:
        offsets = {
          x: reference.x + reference.width / 2 - element.width / 2,
          y: reference.y + reference.height
        };
        break;

      case right:
        offsets = {
          x: reference.x + reference.width,
          y: reference.y + reference.height / 2 - element.height / 2
        };
        break;

      case left:
        offsets = {
          x: reference.x - element.width,
          y: reference.y + reference.height / 2 - element.height / 2
        };
        break;

      default:
        offsets = {
          x: reference.x,
          y: reference.y
        };
    }

    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

    if (mainAxis != null) {
      var len = mainAxis === 'y' ? 'height' : 'width';

      switch (variationPlacement) {
        case start:
          offsets[mainAxis] = Math.floor(offsets[mainAxis]) - Math.floor(reference[len] / 2 - element[len] / 2);
          break;

        case end:
          offsets[mainAxis] = Math.floor(offsets[mainAxis]) + Math.ceil(reference[len] / 2 - element[len] / 2);
          break;
      }
    }

    return offsets;
  });

  function popperOffsets(_ref) {
    var state = _ref.state,
        name = _ref.name;
    // Offsets are the actual position the popper needs to have to be
    // properly positioned near its reference element
    // This is the most basic placement, and will be adjusted by
    // the modifiers in the next step
    state.modifiersData[name] = computeOffsets({
      reference: state.measures.reference,
      element: state.measures.popper,
      strategy: 'absolute',
      placement: state.placement
    });
    return state;
  }

  var popperOffsets$1 = {
    name: 'popperOffsets',
    enabled: true,
    phase: 'read',
    fn: popperOffsets,
    data: {}
  };

  var getViewportRect = (function (element) {
    var win = getWindow(element);
    return {
      width: win.innerWidth,
      height: win.innerHeight,
      x: 0,
      y: 0
    };
  });

  var getDocumentElement = (function (element) {
    return element.ownerDocument.documentElement;
  });

  var getDocumentRect = (function (element) {
    var win = getWindow(element);
    var winScroll = getWindowScroll(element);
    var documentRect = getCompositeRect(getDocumentElement(element), win);
    documentRect.height = Math.max(documentRect.height, win.innerHeight);
    documentRect.width = Math.max(documentRect.width, win.innerWidth);
    documentRect.x = -winScroll.scrollLeft;
    documentRect.y = -winScroll.scrollTop;
    return documentRect;
  });

  var rectToClientRect = (function (rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  });

  // clipping (or hiding) overflowing elements with a position different from
  // `initial`

  function getClippingParents(elementOrVirtualElement) {
    var element = unwrapVirtualElement(elementOrVirtualElement);
    var scrollParents = listScrollParents(element);
    var canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle(element).position);
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

    if (!isElement(clipperElement)) {
      return [];
    }

    return scrollParents.filter(function (scrollParent) {
      return isElement(scrollParent) && scrollParent.contains(clipperElement);
    });
  } // Gets the maximum area that the element is visible in due to any number of
  // clipping parents


  function getClippingRect(elementOrVirtualElement, rootArea) {
    var element = unwrapVirtualElement(elementOrVirtualElement);
    var documentElement = getDocumentElement(element);

    var _getClippingParents = getClippingParents(element),
        firstClippingParent = _getClippingParents[0],
        restClippingParents = _getClippingParents.slice(1); // Fallback to document


    if (rootArea === 'document' && (firstClippingParent === documentElement || !firstClippingParent)) {
      return rectToClientRect(getDocumentRect(documentElement));
    } // Fallback to viewport


    if (rootArea === viewport && !firstClippingParent) {
      return rectToClientRect(getViewportRect(element));
    }

    var clippingRect = restClippingParents.reduce(function (accRect, clippingParent) {
      var rect = getBoundingClientRect(clippingParent);
      accRect.top = Math.max(rect.top, accRect.top);
      accRect.right = Math.min(rect.right, accRect.right);
      accRect.bottom = Math.min(rect.bottom, accRect.bottom);
      accRect.left = Math.max(rect.left, accRect.left);
      return accRect;
    }, getBoundingClientRect(firstClippingParent));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  var getOverflowOffsets = function getOverflowOffsets(popperClientRect, boundaryClientRect) {
    return {
      top: boundaryClientRect.top - popperClientRect.top,
      bottom: popperClientRect.bottom - boundaryClientRect.bottom,
      left: boundaryClientRect.left - popperClientRect.left,
      right: popperClientRect.right - boundaryClientRect.right
    };
  };

  var getOverflowRect = function getOverflowRect(elementOrVirtualElement, area, rootArea) {
    var element = unwrapVirtualElement(elementOrVirtualElement);

    switch (area) {
      case 'clippingParents':
        return getClippingRect(element, rootArea);

      case 'viewport':
        return rectToClientRect(getViewportRect(element));

      default:
        return getBoundingClientRect(area);
    }
  };

  function detectOverflow(_ref) {
    var state = _ref.state,
        options = _ref.options,
        name = _ref.name;
    var _options$area = options.area,
        area = _options$area === void 0 ? clippingParents : _options$area,
        _options$rootArea = options.rootArea,
        rootArea = _options$rootArea === void 0 ? 'document' : _options$rootArea,
        _options$elementConte = options.elementContext,
        elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
        _options$altArea = options.altArea,
        altArea = _options$altArea === void 0 ? false : _options$altArea;
    var altContext = elementContext === popper ? reference : popper;
    var referenceElement = state.elements.reference;
    var popperRect = state.measures.popper;
    var element = state.elements[altArea ? altContext : elementContext];
    var clippingClientRect = getOverflowRect(element, area, rootArea);
    var referenceClientRect = getBoundingClientRect(referenceElement);
    var popperOffsets = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: 'absolute',
      placement: state.placement,
      scroll: {
        scrollTop: 0,
        scrollLeft: 0
      }
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, {}, popperOffsets));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = getOverflowOffsets(elementClientRect, clippingClientRect); // Offsets can be applied only to the popper element

    if (elementContext === popper) {
      var offset = state.modifiersData.offset;
      Object.keys(overflowOffsets).forEach(function (key) {
        var multiply = [right, bottom].includes(key) ? 1 : -1;
        var axis = [top, bottom].includes(key) ? 'y' : 'x';
        overflowOffsets[key] += offset[axis] * multiply;
      });
    }

    state.modifiersData[name] = {
      overflowOffsets: overflowOffsets
    };
    return state;
  }

  var detectOverflow$1 = {
    name: 'detectOverflow',
    enabled: true,
    phase: 'read',
    fn: detectOverflow,
    requires: ['popperOffsets'],
    optionallyRequires: ['offset'],
    data: {}
  };

  // This modifier takes the Popper state and prepares some StyleSheet properties
  // that can be applied to the popper element to make it render in the expected position.
  // Round the offsets to the nearest suitable subpixel based on the DPR
  var roundOffsets = function roundOffsets(_ref) {
    var x = _ref.x,
        y = _ref.y;
    var dpr = window.devicePixelRatio;
    return {
      x: Math.round(x * dpr) / dpr || 0,
      y: Math.round(y * dpr) / dpr || 0
    };
  };

  var mapToStyles = function mapToStyles(_ref2) {
    var offsets = _ref2.offsets,
        position = _ref2.position,
        gpuAcceleration = _ref2.gpuAcceleration;

    var _roundOffsets = roundOffsets(offsets),
        x = _roundOffsets.x,
        y = _roundOffsets.y;

    var hasX = offsets.hasOwnProperty('x');
    var hasY = offsets.hasOwnProperty('y'); // Layer acceleration can disable subpixel rendering which causes slightly
    // blurry text on low PPI displays.
    // Zooming can change the DPR, but it seems to report a value that will
    // cleanly divide the values into the appropriate subpixels.

    if (gpuAcceleration === false || window.devicePixelRatio < 2) {
      return {
        top: hasY ? y + "px" : '',
        left: hasX ? x + "px" : '',
        transform: '',
        position: position
      };
    } else {
      return {
        top: hasY ? '0' : '',
        left: hasX ? '0' : '',
        transform: "translate3d(" + x + "px, " + y + "px, 0)",
        position: position
      };
    }
  };

  function computeStyles(_ref3) {
    var state = _ref3.state,
        options = _ref3.options;
    var _options$gpuAccelerat = options.gpuAcceleration,
        gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat; // popper offsets are always available

    state.styles.popper = Object.assign({}, state.styles.popper, {}, mapToStyles({
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      gpuAcceleration: gpuAcceleration
    })); // arrow offsets may not be available

    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, {}, mapToStyles({
        offsets: state.modifiersData.arrow,
        position: 'absolute',
        gpuAcceleration: gpuAcceleration
      }));
    }

    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      'data-popper-placement': state.placement
    });
    return state;
  }

  var computeStyles$1 = {
    name: 'computeStyles',
    enabled: true,
    phase: 'afterMain',
    fn: computeStyles,
    data: {}
  };

  // and applies them to the HTMLElements such as popper and arrow

  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function (name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name]; // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      } // Flow doesn't support to extend this property, but it's the most
      // effective way to apply styles to an HTMLElement
      // $FlowFixMe


      Object.assign(element.style, style);
      Object.entries(attributes).forEach(function (_ref2) {
        var name = _ref2[0],
            value = _ref2[1];

        if (value === false) {
          element.removeAttribute(name);
        } else {
          element.setAttribute(name, value === true ? '' : value);
        }
      });
    });
    return state;
  }

  function onDestroy$1(_ref3) {
    var state = _ref3.state;
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? Object.assign({}, state.styles[name]) : {});
      var attributes = state.attributes[name] || {}; // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        var _Object$assign;

        return Object.assign({}, style, (_Object$assign = {}, _Object$assign[String(property)] = '', _Object$assign));
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      } // Flow doesn't support to extend this property, but it's the most
      // effective way to apply styles to an HTMLElement
      // $FlowFixMe


      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        return element.removeAttribute(attribute);
      });
    });
  }

  var applyStyles$1 = {
    name: 'applyStyles',
    enabled: true,
    phase: 'write',
    fn: applyStyles,
    onDestroy: onDestroy$1,
    requires: ['computeStyles']
  };

  function distanceAndSkiddingToXY(placement, measures, offsetValue) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].includes(basePlacement) ? -1 : 1;

    var _ref = typeof offsetValue === 'function' ? offsetValue(Object.assign({}, measures, {
      placement: placement
    })) : offsetValue,
        distance = _ref[0],
        skidding = _ref[1];

    distance = (distance || 0) * invertDistance;
    skidding = skidding || 0;
    return [left, right].includes(basePlacement) ? [distance, skidding] : [skidding, distance];
  }

  function offset(_ref2) {
    var state = _ref2.state,
        options = _ref2.options,
        name = _ref2.name;
    var _options$offset = options.offset,
        offset = _options$offset === void 0 ? [0, 0] : _options$offset;

    var _distanceAndSkiddingT = distanceAndSkiddingToXY(state.placement, state.measures, offset),
        x = _distanceAndSkiddingT[0],
        y = _distanceAndSkiddingT[1];

    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
    state.modifiersData[name] = {
      x: x,
      y: y
    };
    return state;
  }

  var offset$1 = {
    name: 'offset',
    enabled: true,
    phase: 'read',
    requires: ['popperOffsets'],
    fn: offset
  };

  var hash = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };
  var getOppositePlacement = (function (placement) {
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  });

  var mergePaddingObject = (function (paddingObject) {
    return Object.assign({
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    }, paddingObject);
  });

  function expandToHashMap(value, keys) {
    return keys.reduce(function (hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  function flip(_ref) {
    var state = _ref.state,
        options = _ref.options,
        name = _ref.name;
    var placement = state.placement;
    var defaultFallbackPlacements = [getOppositePlacement(state.options.placement)];
    var _options$fallbackPlac = options.fallbackPlacements,
        fallbackPlacements = _options$fallbackPlac === void 0 ? defaultFallbackPlacements : _options$fallbackPlac,
        _options$padding = options.padding,
        padding = _options$padding === void 0 ? 0 : _options$padding;
    var overflow = state.modifiersData['detectOverflow:flip'].overflowOffsets;
    var flipIndex = state.modifiersData[name].index;
    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    var placementOrder = [state.options.placement].concat(fallbackPlacements);
    var flippedPlacement = placementOrder[flipIndex];

    if (!flippedPlacement && placement !== state.options.placement) {
      state.placement = state.options.placement;
      state.reset = true;
      return state;
    }

    if (!flippedPlacement && placement === state.options.placement) {
      return state;
    }

    var basePlacement = getBasePlacement(flippedPlacement);
    var fits = overflow[basePlacement] + paddingObject[basePlacement] <= 0;

    if (!fits) {
      state.modifiersData[name].index += 1;
      state.reset = true;
      return state;
    } else if (fits && state.placement !== flippedPlacement) {
      state.placement = flippedPlacement;
      state.reset = true;
      return state;
    }

    return state;
  }

  var flip$1 = {
    name: 'flip',
    enabled: true,
    phase: 'main',
    fn: flip,
    requires: ['detectOverflow:flip'],
    optionallyRequires: ['offset'],
    data: {
      index: 0
    }
  };

  var getAltAxis = (function (axis) {
    return axis === 'x' ? 'y' : 'x';
  });

  var within = (function (min, value, max) {
    return Math.max(min, Math.min(value, max));
  });

  function preventOverflow(_ref) {
    var state = _ref.state,
        options = _ref.options,
        name = _ref.name;
    var _options$mainAxis = options.mainAxis,
        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
        _options$altAxis = options.altAxis,
        checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
        _options$tether = options.tether,
        tether = _options$tether === void 0 ? center : _options$tether,
        _options$padding = options.padding,
        padding = _options$padding === void 0 ? 0 : _options$padding;
    var overflow = state.modifiersData['detectOverflow:preventOverflow'].overflowOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets = state.modifiersData.popperOffsets;
    var referenceRect = state.measures.reference;
    var popperRect = state.measures.popper;
    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    var data = {
      x: 0,
      y: 0
    };

    if (checkMainAxis) {
      var mainSide = mainAxis === 'y' ? top : left;
      var altSide = mainAxis === 'y' ? bottom : right;
      var len = mainAxis === 'y' ? 'height' : 'width';
      var offset = popperOffsets[mainAxis];
      var min = popperOffsets[mainAxis] + overflow[mainSide] + paddingObject[mainSide];
      var max = popperOffsets[mainAxis] - overflow[altSide] - paddingObject[altSide];
      var additive = tether === surfaces ? popperRect[len] / 2 : tether === edges ? -popperRect[len] / 2 : 0; // For the "edges" value, we need to include the arrow in the calculation
      // so the arrow doesn't go outside the reference bounds

      var arrowElement = state.elements.arrow;
      var arrowElementRect = arrowElement && tether === edges ? addClientRectMargins(getLayoutRect(arrowElement), arrowElement) : {
        width: 0,
        height: 0
      };
      var tetherMin = state.modifiersData.popperOffsets[mainAxis] - referenceRect[len] / 2 + additive + arrowElementRect[len];
      var tetherMax = state.modifiersData.popperOffsets[mainAxis] + referenceRect[len] / 2 - additive - arrowElementRect[len];
      var lenCondition = referenceRect[len] > popperRect[len] || tether !== surfaces;
      var preventedOffset = within(tether ? Math.min(min, lenCondition ? tetherMax : tetherMin) : min, offset, tether ? Math.max(max, lenCondition ? tetherMin : tetherMax) : max);
      state.modifiersData.popperOffsets[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset;
    }

    if (checkAltAxis) {
      var _mainSide = mainAxis === 'x' ? top : left;

      var _altSide = mainAxis === 'x' ? bottom : right;

      var _offset = popperOffsets[altAxis];

      var _preventedOffset = within(_offset + overflow[_mainSide] + paddingObject[_mainSide], _offset, _offset - overflow[_altSide] - paddingObject[_altSide]);

      state.modifiersData.popperOffsets[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }

    state.modifiersData[name] = data;
    return state;
  }

  var preventOverflow$1 = {
    name: 'preventOverflow',
    enabled: true,
    phase: 'main',
    fn: preventOverflow,
    requires: ['detectOverflow:preventOverflow'],
    optionallyRequires: ['offset']
  };

  function arrow(_ref) {
    var _state$modifiersData$;

    var state = _ref.state,
        name = _ref.name;
    var arrowElement = state.elements.arrow;
    var popperOffsets = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].includes(basePlacement);
    var len = isVertical ? 'height' : 'width';

    if (!arrowElement) {
      return state;
    }

    var arrowElementRect = addClientRectMargins(getLayoutRect(arrowElement), arrowElement);
    var endDiff = state.measures.reference[len] + state.measures.reference[axis] - popperOffsets[axis] - state.measures.popper[len];
    var startDiff = popperOffsets[axis] - state.measures.reference[axis];
    var centerToReference = endDiff / 2 - startDiff / 2;
    var center = state.measures.popper[len] / 2 - arrowElementRect[len] / 2 + centerToReference; // Make sure the arrow doesn't overflow the popper if the center point is
    // outside of the popper bounds

    center = within(0, center, state.measures.popper[len] - arrowElementRect[len]); // Prevents breaking syntax highlighting...

    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = center, _state$modifiersData$);
    return state;
  }

  function onLoad$1(_ref2) {
    var state = _ref2.state,
        options = _ref2.options;
    var _options$element = options.element,
        arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element; // CSS selector

    if (typeof arrowElement === 'string') {
      arrowElement = state.elements.popper.querySelector(arrowElement);

      if (!arrowElement) {
        return state;
      }
    }

    if (!state.elements.popper.contains(arrowElement)) {
      {
        console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
      }

      return state;
    }

    state.elements.arrow = arrowElement;
    return state;
  }

  var arrow$1 = {
    name: 'arrow',
    enabled: true,
    phase: 'main',
    fn: arrow,
    onLoad: onLoad$1,
    requires: ['popperOffsets'],
    optionallyRequires: ['preventOverflow']
  };

  var defaultModifiers = [eventListeners, popperOffsets$1, Object.assign({}, detectOverflow$1, {
    name: 'detectOverflow:preventOverflow'
  }), Object.assign({}, detectOverflow$1, {
    name: 'detectOverflow:flip',
    options: {
      rootArea: viewport
    }
  }), computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1];
  var createPopper$1 = popperGenerator({
    defaultModifiers: defaultModifiers
  }); // eslint-disable-next-line import/no-unused-modules

  exports.createPopper = createPopper$1;
  exports.popperGenerator = popperGenerator;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=popper.js.map
