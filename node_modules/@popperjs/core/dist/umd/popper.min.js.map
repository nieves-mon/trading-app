{"version":3,"file":"popper.min.js","sources":["../../src/dom-utils/getWindow.js","../../src/dom-utils/getWindowScroll.js","../../src/dom-utils/instanceOf.js","../../src/dom-utils/getComputedStyle.js","../../src/dom-utils/listScrollParents.js","../../src/dom-utils/getScrollParent.js","../../src/dom-utils/getOffsetParent.js","../../src/dom-utils/isTableElement.js","../../src/dom-utils/getCommonOffsetParent.js","../../src/utils/debounce.js","../../src/index.js","../../src/modifiers/eventListeners.js","../../src/dom-utils/getClippingRect.js","../../src/enums.js","../../src/utils/expandToHashMap.js","../../src/dom-utils/getBoundingClientRect.js","../../src/dom-utils/unwrapVirtualElement.js","../../src/dom-utils/getCompositeRect.js","../../src/dom-utils/getScrollSum.js","../../src/dom-utils/getNodeScroll.js","../../src/dom-utils/getHTMLElementScroll.js","../../src/dom-utils/getLayoutRect.js","../../src/dom-utils/getNodeName.js","../../src/dom-utils/getParentNode.js","../../src/dom-utils/addClientRectMargins.js","../../src/dom-utils/getElementMargins.js","../../src/utils/unwrapJqueryElement.js","../../src/utils/orderModifiers.js","../../src/utils/getMainAxisFromPlacement.js","../../src/utils/computeOffsets.js","../../src/utils/getBasePlacement.js","../../src/utils/getVariationPlacement.js","../../src/dom-utils/getViewportRect.js","../../src/dom-utils/getDocumentRect.js","../../src/utils/rectToClientRect.js","../../src/modifiers/detectOverflow.js","../../src/modifiers/computeStyles.js","../../src/utils/getOppositePlacement.js","../../src/utils/mergePaddingObject.js","../../src/popper.js","../../src/modifiers/popperOffsets.js","../../src/modifiers/applyStyles.js","../../src/modifiers/offset.js","../../src/modifiers/flip.js","../../src/modifiers/preventOverflow.js","../../src/utils/getAltAxis.js","../../src/utils/within.js","../../src/modifiers/arrow.js"],"sourcesContent":["// @flow\nexport default function getWindow(node: mixed) {\n  const ownerDocument: ?Document =\n    node != null &&\n    typeof node === 'object' &&\n    node.hasOwnProperty('ownerDocument')\n      ? // $FlowFixMe: assume ownerDocument to be the one we are looking for\n        node.ownerDocument\n      : null;\n  return ownerDocument != null ? ownerDocument.defaultView : window;\n}\n","// @flow\nimport getWindow from './getWindow';\n\nexport default function getWindowScroll(node: Node) {\n  const win = getWindow(node);\n  const scrollLeft = win.pageXOffset;\n  const scrollTop = win.pageYOffset;\n  return { scrollLeft, scrollTop };\n}\n","// @flow\nimport getWindow from './getWindow';\n\n/*:: declare function isElement(node: mixed): boolean %checks(node instanceof\n  Element); */\n\nfunction isElement(node) {\n  const OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement;\n}\n\n/*:: declare function isHTMLElement(node: mixed): boolean %checks(node instanceof\n  HTMLElement); */\n\nfunction isHTMLElement(node) {\n  const OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement;\n}\n\n/*:: declare function isShadowRoot(node: mixed): boolean %checks(node instanceof\n  ShadowRoot); */\n\nfunction isShadowRoot(node) {\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement;\n}\n\nexport { isElement, isHTMLElement, isShadowRoot };\n","// @flow\nimport getWindow from './getWindow';\n\nexport default function getComputedStyle(\n  element: Element\n): CSSStyleDeclaration {\n  return getWindow(element).getComputedStyle(element);\n}\n","// @flow\nimport getScrollParent from './getScrollParent';\nimport getParentNode from './getParentNode';\nimport getNodeName from './getNodeName';\nimport getWindow from './getWindow';\n\nexport default function listScrollParents(\n  element: Node,\n  list: Array<Element> = []\n): Array<Element> {\n  const scrollParent = getScrollParent(element);\n  const isBody = getNodeName(scrollParent) === 'body';\n  const target = isBody ? getWindow(scrollParent) : scrollParent;\n  const updatedList = list.concat(target);\n  return isBody\n    ? updatedList\n    : updatedList.concat(listScrollParents(getParentNode(target)));\n}\n","// @flow\nimport getParentNode from './getParentNode';\nimport getComputedStyle from './getComputedStyle';\nimport getNodeName from './getNodeName';\nimport { isHTMLElement } from './instanceOf';\n\nexport default function getScrollParent(node: Node): HTMLElement {\n  if (['html', 'body', '#document'].includes(getNodeName(node))) {\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node)) {\n    // Firefox want us to check `-x` and `-y` variations as well\n    const { overflow, overflowX, overflowY } = getComputedStyle(node);\n    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n      return node;\n    }\n  }\n\n  return getScrollParent(getParentNode(node));\n}\n","// @flow\nimport getWindow from './getWindow';\nimport getNodeName from './getNodeName';\nimport getComputedStyle from './getComputedStyle';\nimport { isHTMLElement } from './instanceOf';\nimport isTableElement from './isTableElement';\n\nconst getTrueOffsetParent = (element: Element): ?Element =>\n  isHTMLElement(element) ? element.offsetParent : null;\n\nexport default function getOffsetParent(element: Element) {\n  const window = getWindow(element);\n\n  let offsetParent = getTrueOffsetParent(element);\n\n  // Find the nearest non-table offsetParent\n  while (offsetParent && isTableElement(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (\n    offsetParent &&\n    getNodeName(offsetParent) === 'body' &&\n    getComputedStyle(offsetParent).position === 'static'\n  ) {\n    return window;\n  }\n\n  return offsetParent || window;\n}\n","// @flow\nimport getNodeName from './getNodeName';\n\nexport default (element: Element): boolean =>\n  ['table', 'td', 'th'].includes(getNodeName(element));\n","// @flow\nimport getOffsetParent from './getOffsetParent';\nimport { isElement, isShadowRoot } from './instanceOf';\nimport getWindow from './getWindow';\n\nfunction isOffsetContainer(element: Element): boolean {\n  const firstElementChild = element.firstElementChild;\n  return !firstElementChild || getOffsetParent(firstElementChild) === element;\n}\n\nfunction getRoot(node: Node): Node {\n  const parentNode = node.parentNode;\n\n  if (parentNode != null) {\n    return getRoot(parentNode);\n  }\n\n  return node;\n}\n\nexport default function getCommonOffsetParent(\n  element1: Element,\n  element2: Element\n): Element {\n  // If one of the nodes is inside shadowDOM, find which one\n  const element1root = getRoot(element1);\n  const element2root = getRoot(element2);\n\n  if (isShadowRoot(element1root)) {\n    return getCommonOffsetParent(element1root.host, element2);\n  } else if (isShadowRoot(element2root)) {\n    return getCommonOffsetParent(element1, element2root.host);\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  const order =\n    element1.compareDocumentPosition(element2) &\n    Node.DOCUMENT_POSITION_FOLLOWING;\n  const start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n\n  // Both nodes are inside #document\n  // Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  const commonAncestorContainer = range.commonAncestorContainer;\n\n  // If ancestor container is not an element, we must return a safe\n  // fallback, body is a good bet\n  if (!isElement(commonAncestorContainer)) {\n    return getWindow(commonAncestorContainer).body;\n  }\n\n  // if ancestor container is also an offset container, we found our winner\n  if (isOffsetContainer(commonAncestorContainer)) {\n    return commonAncestorContainer;\n  }\n\n  return getOffsetParent(commonAncestorContainer);\n}\n","// @flow\nexport default function microtaskDebounce(fn: Function) {\n  let pending;\n  return () => {\n    if (!pending) {\n      pending = new Promise<void>(resolve => {\n        Promise.resolve().then(() => {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}\n","// @flow\nimport type {\n  JQueryWrapper,\n  State,\n  Options,\n  Modifier,\n  Instance,\n} from './types';\n\nexport * from './types';\nexport * from './enums';\n\n// DOM Utils\nimport getCompositeRect from './dom-utils/getCompositeRect';\nimport getLayoutRect from './dom-utils/getLayoutRect';\nimport listScrollParents from './dom-utils/listScrollParents';\nimport addClientRectMargins from './dom-utils/addClientRectMargins';\nimport getCommonOffsetParent from './dom-utils/getCommonOffsetParent';\nimport unwrapVirtualElement from './dom-utils/unwrapVirtualElement';\n\n// Pure Utils\nimport unwrapJqueryElement from './utils/unwrapJqueryElement';\nimport orderModifiers from './utils/orderModifiers';\nimport debounce from './utils/debounce';\nimport validateModifiers from './utils/validateModifiers';\n\nconst INVALID_ELEMENT_ERROR =\n  'Popper: Invalid reference or popper argument provided to Popper, they must be either a valid DOM element, virtual element, or a jQuery-wrapped DOM element.';\nconst INFINITE_LOOP_ERROR =\n  'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\n\nconst areValidElements = (...args: Array<any>): boolean =>\n  !args.some(\n    element => !(element && typeof element.getBoundingClientRect === 'function')\n  );\n\nconst defaultOptionsValue: Options = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute',\n};\n\ntype PopperGeneratorArgs = {\n  defaultModifiers?: Array<Modifier<any>>,\n  defaultOptions?: $Shape<Options>,\n};\n\nexport function popperGenerator(generatorOptions: PopperGeneratorArgs = {}) {\n  const {\n    defaultModifiers = [],\n    defaultOptions = defaultOptionsValue,\n  } = generatorOptions;\n\n  return function createPopper(\n    reference: HTMLElement | JQueryWrapper,\n    popper: HTMLElement | JQueryWrapper,\n    options: $Shape<Options> = defaultOptions\n  ): Instance {\n    // Unwrap `reference` and `popper` elements in case they are\n    // wrapped by jQuery, otherwise consume them as is\n    const referenceElement = unwrapJqueryElement(reference);\n    const popperElement = unwrapJqueryElement(popper);\n\n    let state: $Shape<State> = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: { ...defaultOptionsValue, ...defaultOptions },\n      modifiersData: {},\n      elements: {\n        reference: referenceElement,\n        popper: popperElement,\n      },\n      attributes: {},\n      styles: {},\n    };\n\n    const instance = {\n      setOptions(options) {\n        // Store options into state\n        state.options = {\n          ...defaultOptions,\n          ...options,\n        };\n\n        state.scrollParents = {\n          reference: listScrollParents(referenceElement),\n          popper: listScrollParents(popperElement),\n        };\n\n        // Order `options.modifiers` so that the dependencies are fulfilled\n        // once the modifiers are executed\n        state.orderedModifiers = orderModifiers([\n          ...state.options.modifiers.filter(\n            modifier =>\n              !defaultModifiers.find(({ name }) => name === modifier.name)\n          ),\n          ...defaultModifiers.map(defaultModifier => ({\n            ...defaultModifier,\n            ...state.options.modifiers.find(\n              ({ name }) => name === defaultModifier.name\n            ),\n          })),\n        ]);\n\n        // Validate the provided modifiers so that the consumer will get warned\n        // if one of the custom modifiers is invalid for any reason\n        if (__DEV__) {\n          validateModifiers(state.orderedModifiers);\n        }\n      },\n      // Syncronous and forcefully executed update\n      // it will always be executed even if not necessary, usually NOT needed\n      // use Popper#update instead\n      forceUpdate() {\n        const {\n          reference: referenceElement,\n          popper: popperElement,\n        } = state.elements;\n        // Don't proceed if `reference` or `popper` are not valid elements anymore\n        if (!areValidElements(referenceElement, popperElement)) {\n          if (__DEV__) {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n          return;\n        }\n\n        const isFixed = state.options.strategy === 'fixed';\n\n        // Get initial measurements\n        // these are going to be used to compute the initial popper offsets\n        // and as cache for any modifier that needs them later\n        state.measures = {\n          reference: getCompositeRect(\n            referenceElement,\n            getCommonOffsetParent(\n              unwrapVirtualElement(referenceElement),\n              popperElement\n            ),\n            isFixed\n          ),\n          // CSS marginsc an be applied to popper elements to quickly\n          // apply offsets dynamically based on some CSS selectors.\n          // For this reason we include margins in this calculation.\n          popper: addClientRectMargins(\n            getLayoutRect(popperElement),\n            popperElement\n          ),\n        };\n\n        // Modifiers have the ability to read the current Popper state, included\n        // the popper offsets, and modify it to address specifc cases\n        state.reset = false;\n\n        // Cache the placement in cache to make it available to the modifiers\n        // modifiers will modify this one (rather than the one in options)\n        const prevPlacement = state.placement;\n        state.placement = state.options.placement;\n\n        state.orderedModifiers.forEach(\n          modifier =>\n            (state.modifiersData[modifier.name] = {\n              ...modifier.data,\n            })\n        );\n\n        let __debug_loops__ = 0;\n        for (let index = 0; index < state.orderedModifiers.length; index++) {\n          if (__DEV__) {\n            __debug_loops__ += 1;\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          const { fn, enabled, options = {}, name } = state.orderedModifiers[\n            index\n          ];\n\n          if (enabled && typeof fn === 'function') {\n            state = fn({ state, options, name, instance });\n          }\n        }\n\n        // Prevents a jitter if elements' size changes based on placement.\n        // This is separate from and does not solve the \"flip flicker\" issue.\n        // We can't know ahead of time (before the placement gets written to the\n        // DOM) what size the element will be due to conditionally applied/\n        // computed CSS based on placement (e.g. margins on arrow)\n        if (prevPlacement !== state.placement) {\n          instance.forceUpdate();\n        }\n      },\n\n      // Async and optimistically optimized update\n      // it will not be executed if not necessary\n      // debounced, so that it only runs at most once-per-tick\n      update: debounce(\n        () =>\n          // prettier-ignore\n          new Promise<$Shape<State>>(resolve => {\n          instance.forceUpdate();\n          resolve(state);\n        })\n      ),\n\n      destroy() {\n        // Run `onDestroy` modifier methods\n        state.orderedModifiers.forEach(\n          ({ onDestroy, enabled, name, options = {} }) =>\n            enabled &&\n            onDestroy &&\n            onDestroy({ state, name, instance, options })\n        );\n      },\n    };\n\n    // Don't proceed if `reference` or `popper` are invalid elements\n    if (!areValidElements(referenceElement, popperElement)) {\n      if (__DEV__) {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n      return instance;\n    }\n\n    instance.setOptions(options);\n\n    // Modifiers have the opportunity to execute some arbitrary code before\n    // the first update cycle is ran, the order of execution will be the same\n    // defined by the modifier dependencies directive.\n    // The `onLoad` function may add or alter the options of themselves\n    state.orderedModifiers.forEach(\n      ({ onLoad, enabled, name, options = {} }) =>\n        enabled &&\n        onLoad &&\n        (state =\n          onLoad({\n            state,\n            name,\n            instance,\n            options,\n          }) || state)\n    );\n\n    instance.update();\n\n    return instance;\n  };\n}\n\nexport const createPopper = popperGenerator();\n","// @flow\nimport type { ModifierArguments, Modifier } from '../types';\nimport getWindow from '../dom-utils/getWindow';\ntype Options = { scroll: boolean, resize: boolean };\n\nconst passive = { passive: true };\n\nfunction toggleEventListeners({ state, instance, scroll, resize }) {\n  if (scroll != null) {\n    const scrollParents = [\n      ...state.scrollParents.reference,\n      ...state.scrollParents.popper,\n    ];\n\n    scrollParents.forEach(scrollParent =>\n      scroll\n        ? scrollParent.addEventListener('scroll', instance.update, passive)\n        : scrollParent.removeEventListener('scroll', instance.update)\n    );\n  }\n\n  if (resize != null) {\n    const window = getWindow(state.elements.popper);\n    resize\n      ? window.addEventListener('resize', instance.update, passive)\n      : window.removeEventListener('resize', instance.update);\n  }\n}\n\nfunction onLoad({\n  state,\n  instance,\n  name,\n  options,\n}: ModifierArguments<Options>) {\n  const { scroll = true, resize = true } = options;\n\n  // cache initial options so we can compare them later\n  state.modifiersData[`${name}#persistent`] = { scroll, resize };\n\n  toggleEventListeners({ state, instance, scroll, resize });\n\n  return state;\n}\n\nfunction onDestroy({ state, instance }: ModifierArguments<Options>) {\n  toggleEventListeners({ state, instance, scroll: false, resize: false });\n}\n\nfunction update({\n  state,\n  options,\n  instance,\n  name,\n}: ModifierArguments<Options>) {\n  const data = state.modifiersData[`${name}#persistent`];\n  let { scroll = true, resize = true } = options;\n\n  // set options to `null` if they didn't change, so we know not to run any logic\n  if (data.scroll === scroll) {\n    scroll = null;\n  }\n  if (data.resize === resize) {\n    resize = null;\n  }\n\n  // Update cache\n  state.modifiersData[`${name}#persistent`] = { scroll, resize };\n\n  toggleEventListeners({ state, instance, scroll, resize });\n\n  return state;\n}\n\nexport default ({\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: update,\n  onLoad,\n  onDestroy,\n  data: {},\n}: Modifier<Options>);\n","// @flow\nimport type { VirtualElement, ClientRectObject } from '../types';\nimport type { RootOverflowArea } from '../enums';\nimport { viewport } from '../enums';\nimport getViewportRect from './getViewportRect';\nimport getDocumentRect from './getDocumentRect';\nimport listScrollParents from './listScrollParents';\nimport getOffsetParent from './getOffsetParent';\nimport getDocumentElement from './getDocumentElement';\nimport getComputedStyle from './getComputedStyle';\nimport unwrapVirtualElement from './unwrapVirtualElement';\nimport { isElement, isHTMLElement } from './instanceOf';\nimport getBoundingClientRect from './getBoundingClientRect';\nimport rectToClientRect from '../utils/rectToClientRect';\n\n// A \"clipping parent\" is a scrolling container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\nfunction getClippingParents(elementOrVirtualElement: Element | VirtualElement) {\n  const element = unwrapVirtualElement(elementOrVirtualElement);\n  const scrollParents = listScrollParents(element);\n  const canEscapeClipping = ['absolute', 'fixed'].includes(\n    getComputedStyle(element).position\n  );\n  const clipperElement =\n    canEscapeClipping && isHTMLElement(element)\n      ? getOffsetParent(element)\n      : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  }\n\n  return scrollParents.filter(scrollParent => {\n    return isElement(scrollParent) && scrollParent.contains(clipperElement);\n  });\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping parents\nexport default function getClippingRect(\n  elementOrVirtualElement: Element | VirtualElement,\n  rootArea: RootOverflowArea\n): ClientRectObject {\n  const element = unwrapVirtualElement(elementOrVirtualElement);\n  const documentElement = getDocumentElement(element);\n  const [firstClippingParent, ...restClippingParents] = getClippingParents(\n    element\n  );\n\n  // Fallback to document\n  if (\n    rootArea === 'document' &&\n    (firstClippingParent === documentElement || !firstClippingParent)\n  ) {\n    return rectToClientRect(getDocumentRect(documentElement));\n  }\n\n  // Fallback to viewport\n  if (rootArea === viewport && !firstClippingParent) {\n    return rectToClientRect(getViewportRect(element));\n  }\n\n  const clippingRect = restClippingParents.reduce((accRect, clippingParent) => {\n    const rect = getBoundingClientRect(clippingParent);\n    accRect.top = Math.max(rect.top, accRect.top);\n    accRect.right = Math.min(rect.right, accRect.right);\n    accRect.bottom = Math.min(rect.bottom, accRect.bottom);\n    accRect.left = Math.max(rect.left, accRect.left);\n    return accRect;\n  }, getBoundingClientRect(firstClippingParent));\n\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n\n  return clippingRect;\n}\n","// @flow\nexport const top: 'top' = 'top';\nexport const bottom: 'bottom' = 'bottom';\nexport const right: 'right' = 'right';\nexport const left: 'left' = 'left';\nexport const auto: 'auto' = 'auto';\nexport type BasePlacement =\n  | typeof top\n  | typeof bottom\n  | typeof right\n  | typeof left;\nexport const basePlacements: Array<BasePlacement> = [top, bottom, right, left];\n\nexport const start: 'start' = 'start';\nexport const end: 'end' = 'end';\nexport type VariationPlacement = typeof start | typeof end;\n\nexport const center: 'center' = 'center';\nexport const edges: 'edges' = 'edges';\nexport const surfaces: 'surfaces' = 'surfaces';\nexport type Tether = false | typeof center | typeof edges | typeof surfaces;\n\nexport const clippingParents: 'clippingParents' = 'clippingParents';\nexport const viewport: 'viewport' = 'viewport';\nexport type OverflowArea =\n  | HTMLElement\n  | typeof clippingParents\n  | typeof viewport;\nexport type RootOverflowArea = typeof viewport | 'document';\n\nexport const popper: 'popper' = 'popper';\nexport const reference: 'reference' = 'reference';\nexport type Context = typeof popper | typeof reference;\n\nexport type Placement =\n  | 'auto'\n  | 'auto-start'\n  | 'auto-end'\n  | 'top'\n  | 'top-start'\n  | 'top-end'\n  | 'bottom'\n  | 'bottom-start'\n  | 'bottom-end'\n  | 'right'\n  | 'right-start'\n  | 'right-end'\n  | 'left'\n  | 'left-start'\n  | 'left-end';\n\nexport const placements: Array<Placement> = basePlacements.reduce(\n  (acc: Array<Placement>, placement: BasePlacement): Array<Placement> =>\n    acc.concat([\n      placement,\n      (`${placement}-${start}`: any),\n      (`${placement}-${end}`: any),\n    ]),\n  []\n);\n\n// modifiers that need to read the DOM\nexport const beforeRead: 'beforeRead' = 'beforeRead';\nexport const read: 'read' = 'read';\nexport const afterRead: 'afterRead' = 'afterRead';\n// pure-logic modifiers\nexport const beforeMain: 'beforeMain' = 'beforeMain';\nexport const main: 'main' = 'main';\nexport const afterMain: 'afterMain' = 'afterMain';\n// modifier with the purpose to write to the DOM (or write into a framework state)\nexport const beforeWrite: 'beforeWrite' = 'beforeWrite';\nexport const write: 'write' = 'write';\nexport const afterWrite: 'afterWrite' = 'afterWrite';\nexport const modifierPhases: Array<ModifierPhases> = [\n  beforeRead,\n  read,\n  afterRead,\n  beforeMain,\n  main,\n  afterMain,\n  beforeWrite,\n  write,\n  afterWrite,\n];\n\nexport type ModifierPhases =\n  | typeof beforeRead\n  | typeof read\n  | typeof afterRead\n  | typeof beforeMain\n  | typeof main\n  | typeof afterMain\n  | typeof beforeWrite\n  | typeof write\n  | typeof afterWrite;\n","// @flow\nexport default function expandToHashMap<\n  T: number | string | boolean,\n  K: string\n>(value: T, keys: Array<K>): { [key: string]: T } {\n  return keys.reduce((hashMap, key) => {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}\n","// @flow\nimport type { ClientRectObject, VirtualElement } from '../types';\n\nexport default (element: Element | VirtualElement): ClientRectObject => {\n  const rect = JSON.parse(JSON.stringify(element.getBoundingClientRect()));\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n};\n","// @flow\nimport type { VirtualElement } from '../types';\nimport { isElement } from './instanceOf';\n\nexport default (element: Element | VirtualElement): Element => {\n  return isElement(element) ? element : element.contextElement;\n};\n","// @flow\nimport type { Rect, VirtualElement } from '../types';\nimport getBoundingClientRect from './getBoundingClientRect';\nimport getScrollSum from './getScrollSum';\nimport unwrapVirtualElement from './unwrapVirtualElement';\nimport { isElement } from './instanceOf';\n\n// Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\nexport default (\n  elementOrVirtualElement: Element | VirtualElement,\n  commonOffsetParent: Element,\n  isFixed: boolean = false\n): Rect => {\n  const element = unwrapVirtualElement(elementOrVirtualElement);\n  const rect = getBoundingClientRect(element);\n  const offsetParentRect =\n    isElement(commonOffsetParent) && !isFixed\n      ? getBoundingClientRect(commonOffsetParent)\n      : { left: 0, top: 0 };\n  const offsetParentScrollSum = getScrollSum(\n    isFixed ? [] : [commonOffsetParent]\n  );\n\n  const width = rect.width;\n  const height = rect.height;\n  const x =\n    rect.left + offsetParentScrollSum.scrollLeft - offsetParentRect.left;\n  const y = rect.top + offsetParentScrollSum.scrollTop - offsetParentRect.top;\n\n  return { width, height, x, y };\n};\n","// @flow\nimport getNodeScroll from './getNodeScroll';\n\nexport default (scrollParents: Array<Element>) =>\n  scrollParents.reduce(\n    (scroll, scrollParent) => {\n      const nodeScroll = getNodeScroll(scrollParent);\n      scroll.scrollTop += nodeScroll.scrollTop;\n      scroll.scrollLeft += nodeScroll.scrollLeft;\n      return scroll;\n    },\n    { scrollTop: 0, scrollLeft: 0 }\n  );\n","// @flow\nimport getWindowScroll from './getWindowScroll';\nimport getWindow from './getWindow';\nimport { isHTMLElement } from './instanceOf';\nimport getHTMLElementScroll from './getHTMLElementScroll';\n\nexport default function getNodeScroll(node: Node) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}\n","// @flow\n\nexport default function getHTMLElementScroll(element: HTMLElement) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop,\n  };\n}\n","// @flow\nimport type { Rect } from '../types';\n\n// Returns the layout rect of an element relative to its offsetParent. Layout\n// means it doesn't take into account transforms.\nexport default (element: HTMLElement): Rect => ({\n  x: element.offsetLeft,\n  y: element.offsetTop,\n  width: element.offsetWidth,\n  height: element.offsetHeight,\n});\n","// @flow\n\nexport default (element: ?Node): ?string =>\n  element ? (element.nodeName || '').toLowerCase() : null;\n","// @flow\nimport getNodeName from './getNodeName';\n\nexport default (element: Node | ShadowRoot): Node => {\n  if (getNodeName(element) === 'html') {\n    // DocumentElement detectedF\n    return element;\n  }\n  return (\n    element.parentNode || // DOM Element detected\n    // $FlowFixMe: need a better way to handle this...\n    element.host || // ShadowRoot detected\n    document.ownerDocument || // Fallback to ownerDocument if available\n    document.documentElement // Or to documentElement if everything else fails\n  );\n};\n","// @flow\nimport type { Rect } from '../types';\nimport getElementMargins from './getElementMargins';\n\nexport default (rect: Rect, element: HTMLElement): Rect => {\n  const margins = getElementMargins(element);\n\n  return {\n    width: rect.width + margins.left + margins.right,\n    height: rect.height + margins.top + margins.bottom,\n    y: rect.y - margins.top,\n    x: rect.x - margins.left,\n  };\n};\n","// @flow\nimport getComputedStyle from './getComputedStyle';\n\nexport default (element: HTMLElement) => {\n  // get the element margins, we need them to properly align the popper\n  const styles = getComputedStyle(element);\n\n  const top = parseFloat(styles.marginTop) || 0;\n  const right = parseFloat(styles.marginRight) || 0;\n  const bottom = parseFloat(styles.marginBottom) || 0;\n  const left = parseFloat(styles.marginLeft) || 0;\n\n  return { top, right, bottom, left };\n};\n","// @flow\nimport type { JQueryWrapper } from '../types';\n\nexport default (element: HTMLElement | JQueryWrapper): HTMLElement =>\n  // $FlowFixMe: need to get type refinement work\n  element.hasOwnProperty('jquery') ? element[0] : element;\n","// @flow\nimport type { Modifier } from '../types';\nimport { modifierPhases } from '../enums';\n\n// source: https://stackoverflow.com/questions/49875255\nconst order = modifiers => {\n  const map = new Map();\n  const visited = new Set();\n  const result = [];\n\n  modifiers.forEach(modifier => {\n    map.set(modifier.name, modifier);\n  });\n\n  // On visiting object, check for its dependencies and visit them recursively\n  function sort(modifier: Modifier<any>) {\n    visited.add(modifier.name);\n\n    const requires = [\n      ...(modifier.requires || []),\n      ...(modifier.optionallyRequires || []),\n    ];\n\n    requires.forEach(dep => {\n      if (!visited.has(dep)) {\n        const depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n\n    result.push(modifier);\n  }\n\n  modifiers.forEach(modifier => {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n\n  return result;\n};\n\nexport default (modifiers: Array<Modifier<any>>): Array<Modifier<any>> => {\n  // order based on dependencies\n  const orderedModifiers = order(modifiers);\n\n  // order based on phase\n  return modifierPhases.reduce((acc, phase) => {\n    return acc.concat(\n      orderedModifiers.filter(modifier => modifier.phase === phase)\n    );\n  }, []);\n};\n","// @flow\nimport type { Placement } from '../enums';\nexport default (placement: Placement): 'x' | 'y' =>\n  ['top', 'bottom'].includes(placement) ? 'x' : 'y';\n","// @flow\nimport getBasePlacement from './getBasePlacement';\nimport getVariationPlacement from './getVariationPlacement';\nimport getMainAxisFromPlacement from './getMainAxisFromPlacement';\nimport type {\n  Rect,\n  PositioningStrategy,\n  Offsets,\n  ClientRectObject,\n} from '../types';\nimport { top, right, bottom, left, start, end, type Placement } from '../enums';\n\nexport default ({\n  reference,\n  element,\n  placement,\n}: {\n  reference: Rect | ClientRectObject,\n  element: Rect | ClientRectObject,\n  strategy: PositioningStrategy,\n  placement?: Placement,\n}): Offsets => {\n  const basePlacement = placement ? getBasePlacement(placement) : null;\n  const variationPlacement = placement\n    ? getVariationPlacement(placement)\n    : null;\n\n  let offsets;\n  switch (basePlacement) {\n    case top:\n      offsets = {\n        x: reference.x + reference.width / 2 - element.width / 2,\n        y: reference.y - element.height,\n      };\n      break;\n    case bottom:\n      offsets = {\n        x: reference.x + reference.width / 2 - element.width / 2,\n        y: reference.y + reference.height,\n      };\n      break;\n    case right:\n      offsets = {\n        x: reference.x + reference.width,\n        y: reference.y + reference.height / 2 - element.height / 2,\n      };\n      break;\n    case left:\n      offsets = {\n        x: reference.x - element.width,\n        y: reference.y + reference.height / 2 - element.height / 2,\n      };\n      break;\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y,\n      };\n  }\n\n  const mainAxis = basePlacement\n    ? getMainAxisFromPlacement(basePlacement)\n    : null;\n\n  if (mainAxis != null) {\n    const len = mainAxis === 'y' ? 'height' : 'width';\n\n    switch (variationPlacement) {\n      case start:\n        offsets[mainAxis] =\n          Math.floor(offsets[mainAxis]) -\n          Math.floor(reference[len] / 2 - element[len] / 2);\n        break;\n      case end:\n        offsets[mainAxis] =\n          Math.floor(offsets[mainAxis]) +\n          Math.ceil(reference[len] / 2 - element[len] / 2);\n        break;\n      default:\n    }\n  }\n\n  return offsets;\n};\n","// @flow\nimport { type BasePlacement, type Placement, auto } from '../enums';\n\nexport default (placement: Placement | typeof auto): BasePlacement =>\n  (placement.split('-')[0]: any);\n","// @flow\nimport { type VariationPlacement, type Placement, auto } from '../enums';\n\nexport default (placement: Placement | typeof auto): ?VariationPlacement =>\n  (placement.split('-')[1]: any);\n","// @flow\nimport getWindow from './getWindow';\n\nexport default (element: Element) => {\n  const win = getWindow(element);\n  return {\n    width: win.innerWidth,\n    height: win.innerHeight,\n    x: 0,\n    y: 0,\n  };\n};\n","// @flow\nimport getCompositeRect from './getCompositeRect';\nimport getWindow from './getWindow';\nimport getDocumentElement from './getDocumentElement';\nimport getWindowScroll from './getWindowScroll';\n\nexport default (element: HTMLElement) => {\n  const win = getWindow(element);\n  const winScroll = getWindowScroll(element);\n  const documentRect = getCompositeRect(getDocumentElement(element), win);\n\n  documentRect.height = Math.max(documentRect.height, win.innerHeight);\n  documentRect.width = Math.max(documentRect.width, win.innerWidth);\n  documentRect.x = -winScroll.scrollLeft;\n  documentRect.y = -winScroll.scrollTop;\n\n  return documentRect;\n};\n","// @flow\n\nimport type { Rect, ClientRectObject } from '../types';\n\nexport default (rect: Rect): ClientRectObject => ({\n  ...rect,\n  left: rect.x,\n  top: rect.y,\n  right: rect.x + rect.width,\n  bottom: rect.y + rect.height,\n});\n","// @flow\nimport type {\n  ModifierArguments,\n  Modifier,\n  ClientRectObject,\n  VirtualElement,\n} from '../types';\nimport type { RootOverflowArea, OverflowArea, Context } from '../enums';\nimport getBoundingClientRect from '../dom-utils/getBoundingClientRect';\nimport getClippingRect from '../dom-utils/getClippingRect';\nimport getViewportRect from '../dom-utils/getViewportRect';\nimport computeOffsets from '../utils/computeOffsets';\nimport rectToClientRect from '../utils/rectToClientRect';\nimport {\n  clippingParents,\n  reference,\n  popper,\n  bottom,\n  top,\n  right,\n} from '../enums';\nimport unwrapVirtualElement from '../dom-utils/unwrapVirtualElement';\n\ntype Options = {\n  area: OverflowArea,\n  rootArea: RootOverflowArea,\n  elementContext: Context,\n  altArea: boolean,\n};\n\n// if the number is positive, the popper is overflowing by that number of pixels\n// when 0, or negative, the popper is within its boundaries\ntype OverflowOffsets = {\n  top: number,\n  bottom: number,\n  right: number,\n  left: number,\n};\n\nconst getOverflowOffsets = (\n  popperClientRect,\n  boundaryClientRect\n): OverflowOffsets => ({\n  top: boundaryClientRect.top - popperClientRect.top,\n  bottom: popperClientRect.bottom - boundaryClientRect.bottom,\n  left: boundaryClientRect.left - popperClientRect.left,\n  right: popperClientRect.right - boundaryClientRect.right,\n});\n\nconst getOverflowRect = (\n  elementOrVirtualElement: Element | VirtualElement,\n  area: OverflowArea,\n  rootArea: RootOverflowArea\n): ClientRectObject => {\n  const element = unwrapVirtualElement(elementOrVirtualElement);\n\n  switch (area) {\n    case 'clippingParents':\n      return getClippingRect(element, rootArea);\n    case 'viewport':\n      return rectToClientRect(getViewportRect(element));\n    default:\n      return getBoundingClientRect(area);\n  }\n};\n\nfunction detectOverflow({ state, options, name }: ModifierArguments<Options>) {\n  const {\n    area = clippingParents,\n    rootArea = 'document',\n    elementContext = popper,\n    altArea = false,\n  } = options;\n\n  const altContext = elementContext === popper ? reference : popper;\n\n  const referenceElement = state.elements.reference;\n  const popperRect = state.measures.popper;\n  const element = state.elements[altArea ? altContext : elementContext];\n\n  const clippingClientRect = getOverflowRect(element, area, rootArea);\n\n  const referenceClientRect = getBoundingClientRect(referenceElement);\n\n  const popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement: state.placement,\n    scroll: {\n      scrollTop: 0,\n      scrollLeft: 0,\n    },\n  });\n\n  const popperClientRect = rectToClientRect({\n    ...popperRect,\n    ...popperOffsets,\n  });\n\n  const elementClientRect =\n    elementContext === popper ? popperClientRect : referenceClientRect;\n\n  const overflowOffsets = getOverflowOffsets(\n    elementClientRect,\n    clippingClientRect\n  );\n\n  // Offsets can be applied only to the popper element\n  if (elementContext === popper) {\n    const offset = state.modifiersData.offset;\n\n    Object.keys(overflowOffsets).forEach(key => {\n      const multiply = [right, bottom].includes(key) ? 1 : -1;\n      const axis = [top, bottom].includes(key) ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  state.modifiersData[name] = {\n    overflowOffsets: overflowOffsets,\n  };\n\n  return state;\n}\n\nexport default ({\n  name: 'detectOverflow',\n  enabled: true,\n  phase: 'read',\n  fn: detectOverflow,\n  requires: ['popperOffsets'],\n  optionallyRequires: ['offset'],\n  data: {},\n}: Modifier<Options>);\n","// @flow\nimport type {\n  PositioningStrategy,\n  Offsets,\n  Modifier,\n  ModifierArguments,\n} from '../types';\n\n// This modifier takes the Popper state and prepares some StyleSheet properties\n// that can be applied to the popper element to make it render in the expected position.\n\ntype Options = {\n  gpuAcceleration?: boolean,\n};\n\n// Round the offsets to the nearest suitable subpixel based on the DPR\nconst roundOffsets = ({ x, y }) => {\n  const dpr = window.devicePixelRatio;\n  return {\n    x: Math.round(x * dpr) / dpr || 0,\n    y: Math.round(y * dpr) / dpr || 0,\n  };\n};\n\nexport const mapToStyles = ({\n  offsets,\n  position,\n  gpuAcceleration,\n}: {\n  offsets: Offsets,\n  position: PositioningStrategy,\n  gpuAcceleration: boolean,\n}) => {\n  const { x, y } = roundOffsets(offsets);\n  const hasX = offsets.hasOwnProperty('x');\n  const hasY = offsets.hasOwnProperty('y');\n\n  // Layer acceleration can disable subpixel rendering which causes slightly\n  // blurry text on low PPI displays.\n  // Zooming can change the DPR, but it seems to report a value that will\n  // cleanly divide the values into the appropriate subpixels.\n  if (gpuAcceleration === false || window.devicePixelRatio < 2) {\n    return {\n      top: hasY ? `${y}px` : '',\n      left: hasX ? `${x}px` : '',\n      transform: '',\n      position,\n    };\n  } else {\n    return {\n      top: hasY ? '0' : '',\n      left: hasX ? '0' : '',\n      transform: `translate3d(${x}px, ${y}px, 0)`,\n      position,\n    };\n  }\n};\n\nfunction computeStyles({ state, options }: ModifierArguments<Options>) {\n  const { gpuAcceleration = true } = options;\n\n  // popper offsets are always available\n  state.styles.popper = {\n    ...state.styles.popper,\n    ...mapToStyles({\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      gpuAcceleration,\n    }),\n  };\n\n  // arrow offsets may not be available\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = {\n      ...state.styles.arrow,\n      ...mapToStyles({\n        offsets: state.modifiersData.arrow,\n        position: 'absolute',\n        gpuAcceleration,\n      }),\n    };\n  }\n\n  state.attributes.popper = {\n    ...state.attributes.popper,\n    'data-popper-placement': state.placement,\n  };\n\n  return state;\n}\n\nexport default ({\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'afterMain',\n  fn: computeStyles,\n  data: {},\n}: Modifier<Options>);\n","// @flow\nimport type { Placement } from '../enums';\n\nconst hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n\nexport default (placement: Placement): Placement =>\n  (placement.replace(/left|right|bottom|top/g, matched => hash[matched]): any);\n","// @flow\nimport type { PaddingObject } from '../types';\n\nexport default (paddingObject: $Shape<PaddingObject>): PaddingObject => ({\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0,\n  ...paddingObject,\n});\n","// @flow\nimport { popperGenerator } from './index';\nimport { viewport } from './enums';\nimport eventListeners from './modifiers/eventListeners';\nimport popperOffsets from './modifiers/popperOffsets';\nimport detectOverflow from './modifiers/detectOverflow';\nimport computeStyles from './modifiers/computeStyles';\nimport applyStyles from './modifiers/applyStyles';\nimport offset from './modifiers/offset';\nimport flip from './modifiers/flip';\nimport preventOverflow from './modifiers/preventOverflow';\nimport arrow from './modifiers/arrow';\n\nconst defaultModifiers = [\n  eventListeners,\n  popperOffsets,\n  {\n    ...detectOverflow,\n    name: 'detectOverflow:preventOverflow',\n  },\n  {\n    ...detectOverflow,\n    name: 'detectOverflow:flip',\n    options: { rootArea: viewport },\n  },\n  computeStyles,\n  applyStyles,\n  offset,\n  flip,\n  preventOverflow,\n  arrow,\n];\n\nconst createPopper = popperGenerator({ defaultModifiers });\n\n// eslint-disable-next-line import/no-unused-modules\nexport { createPopper, popperGenerator };\n","// @flow\nimport type { ModifierArguments, Modifier } from '../types';\nimport computeOffsets from '../utils/computeOffsets';\n\nfunction popperOffsets({ state, name }: ModifierArguments<{||}>) {\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = computeOffsets({\n    reference: state.measures.reference,\n    element: state.measures.popper,\n    strategy: 'absolute',\n    placement: state.placement,\n  });\n\n  return state;\n}\n\nexport default ({\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets,\n  data: {},\n}: Modifier<{||}>);\n","// @flow\nimport type { Modifier, ModifierArguments } from '../types';\nimport getNodeName from '../dom-utils/getNodeName';\nimport { isHTMLElement } from '../dom-utils/instanceOf';\n\n// This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles({ state }: ModifierArguments<{||}>) {\n  Object.keys(state.elements).forEach(name => {\n    const style = state.styles[name] || {};\n\n    const attributes = state.attributes[name] || {};\n    const element = state.elements[name];\n\n    // arrow is optional + virtual elements\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    }\n\n    // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe\n    Object.assign(element.style, style);\n\n    Object.entries(attributes).forEach(([name, value]: [string, any]) => {\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n\n  return state;\n}\n\nfunction onDestroy({ state }: ModifierArguments<{||}>) {\n  Object.keys(state.elements).forEach(name => {\n    const element = state.elements[name];\n    const styleProperties = Object.keys(\n      state.styles.hasOwnProperty(name) ? { ...state.styles[name] } : {}\n    );\n    const attributes = state.attributes[name] || {};\n\n    // Set all values to an empty string to unset them\n    const style = styleProperties.reduce(\n      (style, property) => ({\n        ...style,\n        [String(property)]: '',\n      }),\n      {}\n    );\n\n    // arrow is optional + virtual elements\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    }\n\n    // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe\n    Object.assign(element.style, style);\n\n    Object.keys(attributes).forEach(attribute =>\n      element.removeAttribute(attribute)\n    );\n  });\n}\n\nexport default ({\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  onDestroy,\n  requires: ['computeStyles'],\n}: Modifier<{||}>);\n","// @flow\nimport type { Placement } from '../enums';\nimport type { ModifierArguments, Modifier, Rect } from '../types';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport { top, left, right } from '../enums';\n\nexport function distanceAndSkiddingToXY(\n  placement: Placement,\n  measures: { popper: Rect, reference: Rect },\n  offsetValue: OffsetsFunction | [number, number]\n): [number, number] {\n  const basePlacement = getBasePlacement(placement);\n  const invertDistance = [left, top].includes(basePlacement) ? -1 : 1;\n\n  let [distance, skidding] =\n    typeof offsetValue === 'function'\n      ? offsetValue({\n          ...measures,\n          placement,\n        })\n      : offsetValue;\n\n  distance = (distance || 0) * invertDistance;\n  skidding = skidding || 0;\n\n  return [left, right].includes(basePlacement)\n    ? [distance, skidding]\n    : [skidding, distance];\n}\n\ntype OffsetsFunction = ({\n  popper: Rect,\n  reference: Rect,\n  placement: Placement,\n}) => [?number, ?number];\n\ntype Options = {\n  offset: OffsetsFunction | [number, number],\n};\n\nfunction offset({ state, options, name }: ModifierArguments<Options>) {\n  const { offset = [0, 0] } = options;\n\n  const [x, y] = distanceAndSkiddingToXY(\n    state.placement,\n    state.measures,\n    offset\n  );\n\n  state.modifiersData.popperOffsets.x += x;\n  state.modifiersData.popperOffsets.y += y;\n\n  state.modifiersData[name] = { x, y };\n\n  return state;\n}\n\nexport default ({\n  name: 'offset',\n  enabled: true,\n  phase: 'read',\n  requires: ['popperOffsets'],\n  fn: offset,\n}: Modifier<Options>);\n","// @flow\nimport type { Placement } from '../enums';\nimport type { ModifierArguments, Modifier, Padding } from '../types';\nimport getOppositePlacement from '../utils/getOppositePlacement';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport mergePaddingObject from '../utils/mergePaddingObject';\nimport expandToHashMap from '../utils/expandToHashMap';\nimport { basePlacements } from '../enums';\n\ntype Options = {\n  fallbackPlacements: Array<Placement>,\n  padding: Padding,\n};\n\nfunction flip({ state, options, name }: ModifierArguments<Options>) {\n  const placement = state.placement;\n  const defaultFallbackPlacements = [\n    getOppositePlacement(state.options.placement),\n  ];\n  const {\n    fallbackPlacements = defaultFallbackPlacements,\n    padding = 0,\n  } = options;\n  const overflow = state.modifiersData['detectOverflow:flip'].overflowOffsets;\n  const flipIndex = state.modifiersData[name].index;\n\n  const paddingObject = mergePaddingObject(\n    typeof padding !== 'number'\n      ? padding\n      : expandToHashMap(padding, basePlacements)\n  );\n\n  const placementOrder = [state.options.placement, ...fallbackPlacements];\n\n  const flippedPlacement = placementOrder[flipIndex];\n\n  if (!flippedPlacement && placement !== state.options.placement) {\n    state.placement = state.options.placement;\n    state.reset = true;\n    return state;\n  }\n\n  if (!flippedPlacement && placement === state.options.placement) {\n    return state;\n  }\n\n  const basePlacement = getBasePlacement(flippedPlacement);\n  const fits = overflow[basePlacement] + paddingObject[basePlacement] <= 0;\n\n  if (!fits) {\n    state.modifiersData[name].index += 1;\n    state.reset = true;\n    return state;\n  } else if (fits && state.placement !== flippedPlacement) {\n    state.placement = flippedPlacement;\n    state.reset = true;\n    return state;\n  }\n\n  return state;\n}\n\nexport default ({\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requires: ['detectOverflow:flip'],\n  optionallyRequires: ['offset'],\n  data: { index: 0 },\n}: Modifier<Options>);\n","// @flow\nimport {\n  basePlacements,\n  top,\n  left,\n  right,\n  bottom,\n  surfaces,\n  edges,\n  center,\n} from '../enums';\nimport type { Tether } from '../enums';\nimport type { ModifierArguments, Modifier, Padding } from '../types';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport getAltAxis from '../utils/getAltAxis';\nimport mergePaddingObject from '../utils/mergePaddingObject';\nimport expandToHashMap from '../utils/expandToHashMap';\nimport within from '../utils/within';\nimport addClientRectMargins from '../dom-utils/addClientRectMargins';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\n\ntype Options = {\n  /* Prevents boundaries overflow on the main axis */\n  mainAxis: boolean,\n  /* Prevents boundaries overflow on the alternate axis */\n  altAxis: boolean,\n  /**\n   * Allows the popper to overflow from its boundaries to keep it near its reference element:\n   * - false: popper can never overflow, will detach from reference to stay visible;\n   * - \"center\": popper can overflow once the center of the popper is at the edge of the reference;\n   * - \"edges\": popper can overflow once the opposite edges are level;\n   * - \"surfaces\":  popper can overflow once the surfaces are level;\n   */\n  tether: Tether,\n  /* Sets a padding to the provided boundary */\n  padding: Padding,\n};\n\nfunction preventOverflow({ state, options, name }: ModifierArguments<Options>) {\n  const {\n    mainAxis: checkMainAxis = true,\n    altAxis: checkAltAxis = false,\n    tether = center,\n    padding = 0,\n  } = options;\n  const overflow =\n    state.modifiersData['detectOverflow:preventOverflow'].overflowOffsets;\n  const basePlacement = getBasePlacement(state.placement);\n  const mainAxis = getMainAxisFromPlacement(basePlacement);\n  const altAxis = getAltAxis(mainAxis);\n  const popperOffsets = state.modifiersData.popperOffsets;\n  const referenceRect = state.measures.reference;\n  const popperRect = state.measures.popper;\n  const paddingObject = mergePaddingObject(\n    typeof padding !== 'number'\n      ? padding\n      : expandToHashMap(padding, basePlacements)\n  );\n\n  const data = { x: 0, y: 0 };\n\n  if (checkMainAxis) {\n    const mainSide = mainAxis === 'y' ? top : left;\n    const altSide = mainAxis === 'y' ? bottom : right;\n    const len = mainAxis === 'y' ? 'height' : 'width';\n    const offset = popperOffsets[mainAxis];\n\n    const min =\n      popperOffsets[mainAxis] + overflow[mainSide] + paddingObject[mainSide];\n    const max =\n      popperOffsets[mainAxis] - overflow[altSide] - paddingObject[altSide];\n\n    const additive =\n      tether === surfaces\n        ? popperRect[len] / 2\n        : tether === edges\n        ? -popperRect[len] / 2\n        : 0;\n\n    // For the \"edges\" value, we need to include the arrow in the calculation\n    // so the arrow doesn't go outside the reference bounds\n    const arrowElement = state.elements.arrow;\n    const arrowElementRect =\n      arrowElement && tether === edges\n        ? addClientRectMargins(getLayoutRect(arrowElement), arrowElement)\n        : { width: 0, height: 0 };\n\n    const tetherMin =\n      state.modifiersData.popperOffsets[mainAxis] -\n      referenceRect[len] / 2 +\n      additive +\n      arrowElementRect[len];\n    const tetherMax =\n      state.modifiersData.popperOffsets[mainAxis] +\n      referenceRect[len] / 2 -\n      additive -\n      arrowElementRect[len];\n\n    const lenCondition =\n      referenceRect[len] > popperRect[len] || tether !== surfaces;\n\n    const preventedOffset = within(\n      tether ? Math.min(min, lenCondition ? tetherMax : tetherMin) : min,\n      offset,\n      tether ? Math.max(max, lenCondition ? tetherMin : tetherMax) : max\n    );\n\n    state.modifiersData.popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    const mainSide = mainAxis === 'x' ? top : left;\n    const altSide = mainAxis === 'x' ? bottom : right;\n    const offset = popperOffsets[altAxis];\n\n    const preventedOffset = within(\n      offset + overflow[mainSide] + paddingObject[mainSide],\n      offset,\n      offset - overflow[altSide] - paddingObject[altSide]\n    );\n\n    state.modifiersData.popperOffsets[altAxis] = preventedOffset;\n    data[altAxis] = preventedOffset - offset;\n  }\n\n  state.modifiersData[name] = data;\n\n  return state;\n}\n\nexport default ({\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requires: ['detectOverflow:preventOverflow'],\n  optionallyRequires: ['offset'],\n}: Modifier<Options>);\n","// @flow\n\nexport default (axis: 'x' | 'y'): 'x' | 'y' => (axis === 'x' ? 'y' : 'x');\n","// @flow\n\nexport default (min: number, value: number, max: number): number =>\n  Math.max(min, Math.min(value, max));\n","// @flow\nimport type { Modifier, ModifierArguments } from '../types';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport addClientRectMargins from '../dom-utils/addClientRectMargins';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport within from '../utils/within';\nimport { left, right } from '../enums';\n\ntype Options = { element: HTMLElement | string };\n\nfunction arrow({ state, name }: ModifierArguments<Options>) {\n  const arrowElement = state.elements.arrow;\n  const popperOffsets = state.modifiersData.popperOffsets;\n  const basePlacement = getBasePlacement(state.placement);\n  const axis = getMainAxisFromPlacement(basePlacement);\n  const isVertical = [left, right].includes(basePlacement);\n  const len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement) {\n    return state;\n  }\n\n  const arrowElementRect = addClientRectMargins(\n    getLayoutRect(arrowElement),\n    arrowElement\n  );\n\n  const endDiff =\n    state.measures.reference[len] +\n    state.measures.reference[axis] -\n    popperOffsets[axis] -\n    state.measures.popper[len];\n  const startDiff = popperOffsets[axis] - state.measures.reference[axis];\n\n  const centerToReference = endDiff / 2 - startDiff / 2;\n\n  let center =\n    state.measures.popper[len] / 2 -\n    arrowElementRect[len] / 2 +\n    centerToReference;\n\n  // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n  center = within(\n    0,\n    center,\n    state.measures.popper[len] - arrowElementRect[len]\n  );\n\n  // Prevents breaking syntax highlighting...\n  const axisProp: string = axis;\n  state.modifiersData[name] = { [axisProp]: center };\n\n  return state;\n}\n\nfunction onLoad({ state, options }: ModifierArguments<Options>) {\n  let { element: arrowElement = '[data-popper-arrow]' } = options;\n\n  // CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return state;\n    }\n  }\n\n  if (!state.elements.popper.contains(arrowElement)) {\n    if (__DEV__) {\n      console.error(\n        [\n          'Popper: \"arrow\" modifier\\'s `element` must be a child of the popper',\n          'element.',\n        ].join(' ')\n      );\n    }\n\n    return state;\n  }\n\n  state.elements.arrow = arrowElement;\n\n  return state;\n}\n\nexport default ({\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  onLoad,\n  requires: ['popperOffsets'],\n  optionallyRequires: ['preventOverflow'],\n}: Modifier<Options>);\n"],"names":["getWindow","node","ownerDocument","window","getWindowScroll","scrollLeft","win","scrollTop","isElement","isHTMLElement","isShadowRoot","getComputedStyle","element","listScrollParents","list","scrollParent","getScrollParent","getNodeName","getParentNode","isBody","target","updatedList","getOffsetParent","offsetParent","getTrueOffsetParent","getRoot","parentNode","getCommonOffsetParent","element1","element2","element1root","element2root","order","Node","document","start","end","range","firstElementChild","commonAncestorContainer","microtaskDebounce","fn","pending","Promise","resolve","undefined","popperGenerator","generatorOptions","defaultModifiers","defaultOptions","defaultOptionsValue","reference","popper","options","referenceElement","unwrapJqueryElement","popperElement","state","placement","orderedModifiers","modifiersData","elements","attributes","styles","instance","setOptions","orderModifiers","modifier","defaultModifier","forceUpdate","areValidElements","isFixed","getCompositeRect","unwrapVirtualElement","addClientRectMargins","getLayoutRect","index","name","prevPlacement","update","debounce","destroy","onDestroy","onLoad","toggleEventListeners","scroll","passive","resize","getClippingRect","elementOrVirtualElement","rootArea","documentElement","getClippingParents","scrollParents","clipperElement","firstClippingParent","viewport","restClippingParents","accRect","clippingParent","rect","getBoundingClientRect","Math","clippingRect","getViewportRect","getDocumentRect","expandToHashMap","value","keys","hashMap","key","basePlacements","top","bottom","right","left","acc","modifierPhases","JSON","commonOffsetParent","offsetParentRect","getScrollSum","nodeScroll","width","height","x","offsetParentScrollSum","y","parseFloat","modifiers","map","Map","visited","Set","result","dep","depModifier","sort","phase","args","strategy","getMainAxisFromPlacement","computeOffsets","basePlacement","offsets","mainAxis","len","variationPlacement","winScroll","documentRect","rectToClientRect","enabled","detectOverflow","getOverflowRect","area","elementContext","clippingParents","referenceClientRect","popperRect","popperOffsets","popperClientRect","overflowOffsets","clippingClientRect","elementClientRect","offset","multiply","axis","requires","optionallyRequires","data","mapToStyles","position","gpuAcceleration","dpr","hasX","hasY","transform","hash","getOppositePlacement","matched","mergePaddingObject","paddingObject","eventListeners","popperOffsets$1","computeStyles$1","computeStyles","applyStyles$1","applyStyles","style","Object","onDestroy$1","styleProperties","property","String","attribute","offset$1","invertDistance","offsetValue","measures","distance","skidding","flip$1","flip","defaultFallbackPlacements","flipIndex","padding","fallbackPlacements","flippedPlacement","overflow","fits","preventOverflow$1","preventOverflow","checkMainAxis","tether","center","referenceRect","mainSide","altSide","additive","surfaces","edges","arrowElement","arrowElementRect","min","lenCondition","tetherMax","tetherMin","max","preventedOffset","checkAltAxis","altAxis","arrow$1","arrow","onLoad$1"],"mappings":"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"}