import getOppositePlacement from "../utils/getOppositePlacement.js";
import getBasePlacement from "../utils/getBasePlacement.js";
import mergePaddingObject from "../utils/mergePaddingObject.js";
import expandToHashMap from "../utils/expandToHashMap.js";
import { basePlacements } from "../enums.js";

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var placement = state.placement;
  var defaultFallbackPlacements = [getOppositePlacement(state.options.placement)];
  var _options$fallbackPlac = options.fallbackPlacements,
      fallbackPlacements = _options$fallbackPlac === void 0 ? defaultFallbackPlacements : _options$fallbackPlac,
      _options$padding = options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var overflow = state.modifiersData['detectOverflow:flip'].overflowOffsets;
  var flipIndex = state.modifiersData[name].index;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var placementOrder = [state.options.placement].concat(fallbackPlacements);
  var flippedPlacement = placementOrder[flipIndex];

  if (!flippedPlacement && placement !== state.options.placement) {
    state.placement = state.options.placement;
    state.reset = true;
    return state;
  }

  if (!flippedPlacement && placement === state.options.placement) {
    return state;
  }

  var basePlacement = getBasePlacement(flippedPlacement);
  var fits = overflow[basePlacement] + paddingObject[basePlacement] <= 0;

  if (!fits) {
    state.modifiersData[name].index += 1;
    state.reset = true;
    return state;
  } else if (fits && state.placement !== flippedPlacement) {
    state.placement = flippedPlacement;
    state.reset = true;
    return state;
  }

  return state;
}

export default {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requires: ['detectOverflow:flip'],
  optionallyRequires: ['offset'],
  data: {
    index: 0
  }
};