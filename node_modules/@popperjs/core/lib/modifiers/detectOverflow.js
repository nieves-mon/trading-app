import getBoundingClientRect from "../dom-utils/getBoundingClientRect.js";
import getClippingRect from "../dom-utils/getClippingRect.js";
import getViewportRect from "../dom-utils/getViewportRect.js";
import computeOffsets from "../utils/computeOffsets.js";
import rectToClientRect from "../utils/rectToClientRect.js";
import { clippingParents, reference, popper, bottom, top, right } from "../enums.js";
import unwrapVirtualElement from "../dom-utils/unwrapVirtualElement.js";

var getOverflowOffsets = function getOverflowOffsets(popperClientRect, boundaryClientRect) {
  return {
    top: boundaryClientRect.top - popperClientRect.top,
    bottom: popperClientRect.bottom - boundaryClientRect.bottom,
    left: boundaryClientRect.left - popperClientRect.left,
    right: popperClientRect.right - boundaryClientRect.right
  };
};

var getOverflowRect = function getOverflowRect(elementOrVirtualElement, area, rootArea) {
  var element = unwrapVirtualElement(elementOrVirtualElement);

  switch (area) {
    case 'clippingParents':
      return getClippingRect(element, rootArea);

    case 'viewport':
      return rectToClientRect(getViewportRect(element));

    default:
      return getBoundingClientRect(area);
  }
};

function detectOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$area = options.area,
      area = _options$area === void 0 ? clippingParents : _options$area,
      _options$rootArea = options.rootArea,
      rootArea = _options$rootArea === void 0 ? 'document' : _options$rootArea,
      _options$elementConte = options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altArea = options.altArea,
      altArea = _options$altArea === void 0 ? false : _options$altArea;
  var altContext = elementContext === popper ? reference : popper;
  var referenceElement = state.elements.reference;
  var popperRect = state.measures.popper;
  var element = state.elements[altArea ? altContext : elementContext];
  var clippingClientRect = getOverflowRect(element, area, rootArea);
  var referenceClientRect = getBoundingClientRect(referenceElement);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: state.placement,
    scroll: {
      scrollTop: 0,
      scrollLeft: 0
    }
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, {}, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = getOverflowOffsets(elementClientRect, clippingClientRect); // Offsets can be applied only to the popper element

  if (elementContext === popper) {
    var offset = state.modifiersData.offset;
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].includes(key) ? 1 : -1;
      var axis = [top, bottom].includes(key) ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  state.modifiersData[name] = {
    overflowOffsets: overflowOffsets
  };
  return state;
}

export default {
  name: 'detectOverflow',
  enabled: true,
  phase: 'read',
  fn: detectOverflow,
  requires: ['popperOffsets'],
  optionallyRequires: ['offset'],
  data: {}
};