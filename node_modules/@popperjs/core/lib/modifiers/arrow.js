import getBasePlacement from "../utils/getBasePlacement.js";
import addClientRectMargins from "../dom-utils/addClientRectMargins.js";
import getLayoutRect from "../dom-utils/getLayoutRect.js";
import getMainAxisFromPlacement from "../utils/getMainAxisFromPlacement.js";
import within from "../utils/within.js";
import { left, right } from "../enums.js";

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].includes(basePlacement);
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement) {
    return state;
  }

  var arrowElementRect = addClientRectMargins(getLayoutRect(arrowElement), arrowElement);
  var endDiff = state.measures.reference[len] + state.measures.reference[axis] - popperOffsets[axis] - state.measures.popper[len];
  var startDiff = popperOffsets[axis] - state.measures.reference[axis];
  var centerToReference = endDiff / 2 - startDiff / 2;
  var center = state.measures.popper[len] / 2 - arrowElementRect[len] / 2 + centerToReference; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  center = within(0, center, state.measures.popper[len] - arrowElementRect[len]); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = center, _state$modifiersData$);
  return state;
}

function onLoad(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element; // CSS selector

  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return state;
    }
  }

  if (!state.elements.popper.contains(arrowElement)) {
    if (undefined !== "production") {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
    }

    return state;
  }

  state.elements.arrow = arrowElement;
  return state;
}

export default {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  onLoad: onLoad,
  requires: ['popperOffsets'],
  optionallyRequires: ['preventOverflow']
};