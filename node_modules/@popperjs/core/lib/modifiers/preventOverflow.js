import { basePlacements, top, left, right, bottom, surfaces, edges, center } from "../enums.js";
import getBasePlacement from "../utils/getBasePlacement.js";
import getMainAxisFromPlacement from "../utils/getMainAxisFromPlacement.js";
import getAltAxis from "../utils/getAltAxis.js";
import mergePaddingObject from "../utils/mergePaddingObject.js";
import expandToHashMap from "../utils/expandToHashMap.js";
import within from "../utils/within.js";
import addClientRectMargins from "../dom-utils/addClientRectMargins.js";
import getLayoutRect from "../dom-utils/getLayoutRect.js";

function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? center : _options$tether,
      _options$padding = options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var overflow = state.modifiersData['detectOverflow:preventOverflow'].overflowOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.measures.reference;
  var popperRect = state.measures.popper;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var data = {
    x: 0,
    y: 0
  };

  if (checkMainAxis) {
    var mainSide = mainAxis === 'y' ? top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = popperOffsets[mainAxis] + overflow[mainSide] + paddingObject[mainSide];
    var max = popperOffsets[mainAxis] - overflow[altSide] - paddingObject[altSide];
    var additive = tether === surfaces ? popperRect[len] / 2 : tether === edges ? -popperRect[len] / 2 : 0; // For the "edges" value, we need to include the arrow in the calculation
    // so the arrow doesn't go outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowElementRect = arrowElement && tether === edges ? addClientRectMargins(getLayoutRect(arrowElement), arrowElement) : {
      width: 0,
      height: 0
    };
    var tetherMin = state.modifiersData.popperOffsets[mainAxis] - referenceRect[len] / 2 + additive + arrowElementRect[len];
    var tetherMax = state.modifiersData.popperOffsets[mainAxis] + referenceRect[len] / 2 - additive - arrowElementRect[len];
    var lenCondition = referenceRect[len] > popperRect[len] || tether !== surfaces;
    var preventedOffset = within(tether ? Math.min(min, lenCondition ? tetherMax : tetherMin) : min, offset, tether ? Math.max(max, lenCondition ? tetherMin : tetherMax) : max);
    state.modifiersData.popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _mainSide = mainAxis === 'x' ? top : left;

    var _altSide = mainAxis === 'x' ? bottom : right;

    var _offset = popperOffsets[altAxis];

    var _preventedOffset = within(_offset + overflow[_mainSide] + paddingObject[_mainSide], _offset, _offset - overflow[_altSide] - paddingObject[_altSide]);

    state.modifiersData.popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
  return state;
}

export default {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requires: ['detectOverflow:preventOverflow'],
  optionallyRequires: ['offset']
};