export * from './types.js';
export * from './enums.js'; // DOM Utils

import getCompositeRect from "./dom-utils/getCompositeRect.js";
import getLayoutRect from "./dom-utils/getLayoutRect.js";
import listScrollParents from "./dom-utils/listScrollParents.js";
import addClientRectMargins from "./dom-utils/addClientRectMargins.js";
import getCommonOffsetParent from "./dom-utils/getCommonOffsetParent.js";
import unwrapVirtualElement from "./dom-utils/unwrapVirtualElement.js"; // Pure Utils

import unwrapJqueryElement from "./utils/unwrapJqueryElement.js";
import orderModifiers from "./utils/orderModifiers.js";
import debounce from "./utils/debounce.js";
import validateModifiers from "./utils/validateModifiers.js";
var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided to Popper, they must be either a valid DOM element, virtual element, or a jQuery-wrapped DOM element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';

var areValidElements = function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
};

var defaultOptionsValue = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};
export function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? defaultOptionsValue : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    // Unwrap `reference` and `popper` elements in case they are
    // wrapped by jQuery, otherwise consume them as is
    var referenceElement = unwrapJqueryElement(reference);
    var popperElement = unwrapJqueryElement(popper);
    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, defaultOptionsValue, {}, defaultOptions),
      modifiersData: {},
      elements: {
        reference: referenceElement,
        popper: popperElement
      },
      attributes: {},
      styles: {}
    };
    var instance = {
      setOptions: function setOptions(options) {
        // Store options into state
        state.options = Object.assign({}, defaultOptions, {}, options);
        state.scrollParents = {
          reference: listScrollParents(referenceElement),
          popper: listScrollParents(popperElement)
        }; // Order `options.modifiers` so that the dependencies are fulfilled
        // once the modifiers are executed

        state.orderedModifiers = orderModifiers([].concat(state.options.modifiers.filter(function (modifier) {
          return !defaultModifiers.find(function (_ref) {
            var name = _ref.name;
            return name === modifier.name;
          });
        }), defaultModifiers.map(function (defaultModifier) {
          return Object.assign({}, defaultModifier, {}, state.options.modifiers.find(function (_ref2) {
            var name = _ref2.name;
            return name === defaultModifier.name;
          }));
        }))); // Validate the provided modifiers so that the consumer will get warned
        // if one of the custom modifiers is invalid for any reason

        if (undefined !== "production") {
          validateModifiers(state.orderedModifiers);
        }
      },
      // Syncronous and forcefully executed update
      // it will always be executed even if not necessary, usually NOT needed
      // use Popper#update instead
      forceUpdate: function forceUpdate() {
        var _state$elements = state.elements,
            referenceElement = _state$elements.reference,
            popperElement = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements anymore

        if (!areValidElements(referenceElement, popperElement)) {
          if (undefined !== "production") {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return;
        }

        var isFixed = state.options.strategy === 'fixed'; // Get initial measurements
        // these are going to be used to compute the initial popper offsets
        // and as cache for any modifier that needs them later

        state.measures = {
          reference: getCompositeRect(referenceElement, getCommonOffsetParent(unwrapVirtualElement(referenceElement), popperElement), isFixed),
          // CSS marginsc an be applied to popper elements to quickly
          // apply offsets dynamically based on some CSS selectors.
          // For this reason we include margins in this calculation.
          popper: addClientRectMargins(getLayoutRect(popperElement), popperElement)
        }; // Modifiers have the ability to read the current Popper state, included
        // the popper offsets, and modify it to address specifc cases

        state.reset = false; // Cache the placement in cache to make it available to the modifiers
        // modifiers will modify this one (rather than the one in options)

        var prevPlacement = state.placement;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (undefined !== "production") {
            __debug_loops__ += 1;

            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }

          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              enabled = _state$orderedModifie.enabled,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (enabled && typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            });
          }
        } // Prevents a jitter if elements' size changes based on placement.
        // This is separate from and does not solve the "flip flicker" issue.
        // We can't know ahead of time (before the placement gets written to the
        // DOM) what size the element will be due to conditionally applied/
        // computed CSS based on placement (e.g. margins on arrow)


        if (prevPlacement !== state.placement) {
          instance.forceUpdate();
        }
      },
      // Async and optimistically optimized update
      // it will not be executed if not necessary
      // debounced, so that it only runs at most once-per-tick
      update: debounce(function () {
        return (// prettier-ignore
          new Promise(function (resolve) {
            instance.forceUpdate();
            resolve(state);
          })
        );
      }),
      destroy: function destroy() {
        // Run `onDestroy` modifier methods
        state.orderedModifiers.forEach(function (_ref3) {
          var onDestroy = _ref3.onDestroy,
              enabled = _ref3.enabled,
              name = _ref3.name,
              _ref3$options = _ref3.options,
              options = _ref3$options === void 0 ? {} : _ref3$options;
          return enabled && onDestroy && onDestroy({
            state: state,
            name: name,
            instance: instance,
            options: options
          });
        });
      }
    }; // Don't proceed if `reference` or `popper` are invalid elements

    if (!areValidElements(referenceElement, popperElement)) {
      if (undefined !== "production") {
        console.error(INVALID_ELEMENT_ERROR);
      }

      return instance;
    }

    instance.setOptions(options); // Modifiers have the opportunity to execute some arbitrary code before
    // the first update cycle is ran, the order of execution will be the same
    // defined by the modifier dependencies directive.
    // The `onLoad` function may add or alter the options of themselves

    state.orderedModifiers.forEach(function (_ref4) {
      var onLoad = _ref4.onLoad,
          enabled = _ref4.enabled,
          name = _ref4.name,
          _ref4$options = _ref4.options,
          options = _ref4$options === void 0 ? {} : _ref4$options;
      return enabled && onLoad && (state = onLoad({
        state: state,
        name: name,
        instance: instance,
        options: options
      }) || state);
    });
    instance.update();
    return instance;
  };
}
export var createPopper = popperGenerator();